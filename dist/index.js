function t(t,e,i,n){Object.defineProperty(t,e,{get:i,set:n,enumerable:!0,configurable:!0})}let e;var i;t(module.exports,"Direction",(()=>e)),t(module.exports,"Directions",(()=>n)),t(module.exports,"GestureState",(()=>s)),t(module.exports,"Geometry",(()=>v)),t(module.exports,"PointerListener",(()=>w)),t(module.exports,"GestureEvent",(()=>P)),t(module.exports,"Tap",(()=>b)),t(module.exports,"Press",(()=>I)),t(module.exports,"Pan",(()=>f)),t(module.exports,"TwoFingerPan",(()=>x)),t(module.exports,"Pinch",(()=>S)),t(module.exports,"Rotate",(()=>B)),(i=e||(e={})).None="0",i.Left="left",i.Right="right",i.Up="up",i.Down="down";const n=Object.freeze({Horizontal:[e.Left,e.Right],Vertical:[e.Up,e.Down],All:[e.Left,e.Right,e.Up,e.Down,e.None]});let s;var r;let o;var a;let l;var c;(r=s||(s={})).Inactive="inactive",r.Active="active",r.Blocked="blocked",(a=o||(o={})).NoPointer="nopointer",a.SinglePointer="singlepointer",a.DualPointer="dualpointer",(c=l||(l={})).NoActiveGesture="noactivegesture",c.ActiveGesture="activegesture";class h{constructor(t,e){this.x=t,this.y=e}}class u{constructor(t,i){this.startPoint=t,this.endPoint=i,this.direction=e.None,this.deltaX=this.endPoint.x-this.startPoint.x,this.deltaY=this.endPoint.y-this.startPoint.y,this.x=this.deltaX,this.y=this.deltaY,this.vectorLength=Math.sqrt(Math.pow(this.deltaX,2)+Math.pow(this.deltaY,2)),Math.abs(this.deltaX)>Math.abs(this.deltaY)?this.startPoint.x<this.endPoint.x?this.direction=e.Right:this.startPoint.x>this.endPoint.x&&(this.direction=e.Left):this.startPoint.y<this.endPoint.y?this.direction=e.Down:this.startPoint.y>this.endPoint.y&&(this.direction=e.Up)}}class v{static getVector(t,e){const i=new h(t.clientX,t.clientY),n=new h(e.clientX,e.clientY);return new u(i,n)}static getSpeed(t,e,i){let n=0;const s=(i-e)/1e3;return null!=t&&0!=s&&(n=t.vectorLength/s),n}static calculateRotationAngle(t,e){const i=new u(t.startPoint,e.startPoint),n=new u(t.endPoint,e.endPoint),s=new h(0,0),r=new u(i.startPoint,s),o=this.translatePoint(i.endPoint,r),a=new u(n.startPoint,s),l=this.translatePoint(n.endPoint,a),c=-1*this.calcAngleRad(o),v=l.x*Math.cos(c)-l.y*Math.sin(c),p=Math.round(l.x*Math.sin(c)+l.y*Math.cos(c));return 180*Math.atan2(p,v)/Math.PI}static calculateVectorAngle(t,e){let i=0;if(t.vectorLength>0&&e.vectorLength>0){const n=(t.x*e.x+t.y*e.y)/(t.vectorLength*e.vectorLength),s=Math.acos(n);i=this.rad2deg(s)}return i}static translatePoint(t,e){const i=t.x+e.x,n=t.y+e.y;return new h(i,n)}static calcAngleDegrees(t){let e=180*Math.atan2(t.y,t.x)/Math.PI;return e<0&&(e=360+e),e}static calcAngleRad(t){let e=Math.atan2(t.y,t.x);return e<0&&(e=2*Math.PI+e),e}static deg2rad(t){return Math.PI/180*t}static rad2deg(t){return t/(Math.PI/180)}static getCenter(t,e){const i=(t.x+e.x)/2,n=(t.y+e.y)/2;return new h(i,n)}static getCenterMovementVector(t,e){const i=this.getCenter(t.startPoint,e.startPoint),n=this.getCenter(t.endPoint,e.endPoint);return new u(i,n)}static calculateAbsoluteDistanceChange(t,e){const i=new u(t.startPoint,e.startPoint);return new u(t.endPoint,e.endPoint).vectorLength-i.vectorLength}static calculateRelativeDistanceChange(t,e){const i=new u(t.startPoint,e.startPoint);return new u(t.endPoint,e.endPoint).vectorLength/i.vectorLength}}class p{constructor(t){this.pointer=t,this.parameters=t.parameters}getTarget(){return this.pointer.initialPointerEvent.target}getCurrentPointerEvent(){return this.pointer.currentPointerEvent}getCurrentDirection(){return this.parameters.live.vector.direction}onIdle(){}onPointerMove(t){}onPointerUp(t){}onPointerLeave(t){}onPointerCancel(t){}}let d;var m;(m=d||(d={})).Active="active",m.Removed="removed",m.Canceled="canceled";class g{constructor(t,e){this.options={DEBUG:!1,...e},this.DEBUG=this.options.DEBUG;const i=(new Date).getTime();this.pointerId=t.pointerId,this.vectorTimespan=this.options.vectorTimespan??100,this.initialPointerEvent=t,this.currentPointerEvent=t,this.recognizedEvents=[t],this.state=d.Active;const n=v.getVector(t,t),s={global:{startX:this.initialPointerEvent.clientX,startY:this.initialPointerEvent.clientY,vector:n,deltaX:0,deltaY:0,startTimestampUTC:i,startTimestamp:this.initialPointerEvent.timeStamp,currentTimestamp:this.initialPointerEvent.timeStamp,endTimestamp:null,maximumSpeed:0,currentSpeed:0,distance:0,maximumDistance:0,averageSpeed:0,finalSpeed:0,traveledDistance:0,hasBeenMoved:!1,duration:0},live:{duration:0,speed:0,vector:n,distance:0,isMoving:!1}};this.parameters=s}getTarget(){return this.initialPointerEvent.target}reset(){}onIdle(){const t=(new Date).getTime()-this.parameters.global.startTimestampUTC;this.parameters.global.duration=t}onPointerMove(t){this.parameters.global.hasBeenMoved=!0,this.parameters.live.isMoving=!0,this.update(t)}onPointerUp(t){this.parameters.global.finalSpeed=this.parameters.live.speed,this.parameters.live.speed=0,this.parameters.live.isMoving=!1,this.state=d.Removed,this.parameters.global.endTimestamp=t.timeStamp,this.update(t),!0===this.DEBUG&&console.log(`[PointerInput] pointerdown ended. pointerdown duration: ${this.parameters.global.duration}ms`)}onPointerLeave(t){this.onPointerUp(t)}onPointerCancel(t){this.update(t),this.parameters.live.speed=0,this.state=d.Canceled,this.parameters.live.isMoving=!1,this.parameters.global.endTimestamp=t.timeStamp,!0===this.DEBUG&&console.log(`[PointerInput] canceled, pointerdown duration:${this.parameters.global.duration}ms`)}update(t){this.currentPointerEvent=t,this.recognizedEvents.push(t);const e=this.getTimedPointerEvents(),i=v.getVector(e[0],e[1]);this.parameters.live.vector=i,this.parameters.live.distance=i.vectorLength,this.parameters.live.speed=v.getSpeed(i,e[0].timeStamp,e[1].timeStamp),this.parameters.live.speed>this.parameters.global.maximumSpeed&&(this.parameters.global.maximumSpeed=this.parameters.live.speed),this.parameters.global.currentTimestamp=t.timeStamp,this.parameters.global.duration=t.timeStamp-this.parameters.global.startTimestamp,this.parameters.global.deltaX=i.endPoint.x-this.parameters.global.startX,this.parameters.global.deltaY=i.endPoint.y-this.parameters.global.startY;const n=v.getVector(this.initialPointerEvent,this.currentPointerEvent);this.parameters.global.vector=n,this.parameters.global.distance=n.vectorLength,n.vectorLength>this.parameters.global.maximumDistance&&(this.parameters.global.maximumDistance=n.vectorLength),!0===this.DEBUG&&(console.log(`[PointerInput] current speed: ${this.parameters.live.speed}px/s`),console.log(`[PointerInput] pointerdown duration: ${this.parameters.global.duration}ms`),console.log(`[PointerInput] live vector length within vectorTimespan: ${this.parameters.live.vector.vectorLength}px`))}getTimedPointerEvents(){let t=this.initialPointerEvent;const e=this.recognizedEvents[this.recognizedEvents.length-1];let i=this.recognizedEvents.length-1,n=0;const s=e.timeStamp;for(;n<this.vectorTimespan&&(i-=1,!(i<0));)t=this.recognizedEvents[i],n=s-t.timeStamp;const r=[t,e];return this.recognizedEvents=this.recognizedEvents.slice(-20),r}}const P=CustomEvent;class E{constructor(t,e){this.state=s.Inactive,this.validPointerManagerState=null,this.validPointerInputConstructor=p,this.domElement=t,this.initialPointerEvent=null,this.initialParameters=null,this.activeStateParameters=null,this.options={bubbles:!0,blocks:[],supportedDirections:[],DEBUG:!1,...e},this.DEBUG=this.options.DEBUG}getEmptyGestureParameters(){return{global:{min:{},max:{},boolean:{}},live:{min:{},max:{},boolean:{}}}}getGestureParameters(){let t;if(this.state==s.Active?(t=this.activeStateParameters,1==this.DEBUG&&(console.log(`[${this.eventBaseName}] validating using activeStateParameters`),console.log(t))):(1==this.DEBUG&&console.log(`[${this.eventBaseName}] validating using initialParameters`),t=this.initialParameters),null==t)throw new Error("[Gesture] no gesture parameters found. Do not call .getGestureParameters on abstract class Gesture");return t}validateGestureParameters(t){const e=this.getGestureParameters();let i,n=!0;for(i in e){const s=e[i],r=t.parameters[i];let o;for(o in s){const t=s[o];let e;for(e in t){const s=t[e],a=e.startsWith("absolute")?Math.abs(r[e]):r[e];if(1==this.DEBUG&&console.log(`[${this.eventBaseName}] validating ${i} ${o}: required: ${s}, pointer: ${a}`),"boolean"==typeof s&&"boolean"==typeof a?n=this.validateBooleanParameter(s,a):"number"==typeof s&&"number"==typeof a&&(n=this.validateMinMaxParameter(s,a,o)),0==n)return 1==this.DEBUG&&console.log(`[${this.eventBaseName}] invalidated `),!1}}}return!0}validateBooleanParameter(t,e){return null==t||(t==e?(1==this.DEBUG&&console.log(`validated: required value: ${t}, current value: ${e}`),!0):(1==this.DEBUG&&console.log(`dismissing ${this.eventBaseName}: required value: ${t}, current value: ${e}`),!1))}validateMinMaxParameter(t,e,i){if("min"==i){if(e>=t)return!0}else if("max"==i&&e<=t)return!0;return!1}validateDirection(t){const e=t.getCurrentDirection();return!(this.options.supportedDirections.length&&!this.options.supportedDirections.includes(e))||(1==this.DEBUG&&console.log(`[Gestures] dismissing ${this.eventBaseName}: supported directions: ${this.options.supportedDirections}, current direction: ${e}`),!1)}validateGestureState(){return this.state!=s.Blocked}validatePointerManagerState(t){return t.state==this.validPointerManagerState||(1==this.DEBUG&&console.log(`[Gesture] PointerManagerState invalidated ${this.eventBaseName}: ${t.state}`),!1)}validatePointerInputConstructor(t){return t instanceof this.validPointerInputConstructor||(1==this.DEBUG&&console.log(`[Gesture] PointerInputConstructor invalidated ${this.eventBaseName}: ${this.validPointerInputConstructor}`),!1)}validate(t){let e=this.validateGestureState();1==e&&(e=this.validatePointerManagerState(t));const i=t.activePointerInput;return 1==e&&null!=i&&(e=this.validatePointerInputConstructor(i),1==e&&(e=this.validateDirection(i)),1==e&&(e=this.validateGestureParameters(i))),e}recognize(t){const e=this.validate(t);1==e&&this.state==s.Inactive&&this.onStart(t),1==e&&this.state==s.Active?(null==this.initialPointerEvent&&this.setInitialPointerEvent(t),this.emit(t)):this.state==s.Active&&0==e?this.onEnd(t):1==this.DEBUG&&console.log(`not firing event ${this.eventBaseName}. No SinglePointerInput found`)}getPointerInput(t){if(1==t.hasPointersOnSurface()&&t.activePointerInput instanceof this.validPointerInputConstructor)return t.activePointerInput;if(t.lastRemovedPointer instanceof g){const e=t.getlastRemovedPointerInput();if(e instanceof this.validPointerInputConstructor)return e}return null}setInitialPointerEvent(t){const e=this.getPointerInput(t);if(e instanceof this.validPointerInputConstructor){const t=e.getCurrentPointerEvent();this.initialPointerEvent=t}}emit(t,i){i=i||this.eventBaseName,!0===this.DEBUG&&console.log(`[Gestures] detected and firing event ${i}`);const n=this.getPointerInput(t);if(null!=n){const t=n.getTarget();if(t instanceof EventTarget){const s=this.getEventData(n),r={detail:s,bubbles:this.options.bubbles},o=new P(i,r);1==r.bubbles?t.dispatchEvent(o):this.domElement.dispatchEvent(o);const a=s.live.direction;if(1==!!this.options.supportedDirections&&a!=e.None&&(i==this.eventBaseName||"swipe"==i))for(let e=0;e<this.options.supportedDirections.length;e++){const n=this.options.supportedDirections[e];if(n==a){const e=i+n;1==this.DEBUG&&console.log(`[Gestures] detected and firing event ${e}`);const s=new CustomEvent(e,r);1==r.bubbles?t.dispatchEvent(s):this.domElement.dispatchEvent(s)}}}}}onStart(t){this.blockGestures(),this.state=s.Active,this.setInitialPointerEvent(t);const e=`${this.eventBaseName}start`;this.emit(t,e)}onEnd(t){this.unblockGestures(),1==this.DEBUG&&console.log(`[${this.eventBaseName}] ended. Setting ${this.eventBaseName}.state = ${s.Inactive}`),this.state=s.Inactive;const e=`${this.eventBaseName}end`;this.emit(t,e)}onTouchStart(t){}onTouchMove(t){}onTouchEnd(t){}onTouchCancel(t){}block(t){-1==this.options.blocks.indexOf(t)&&this.options.blocks.push(t)}unblock(t){-1!=this.options.blocks.indexOf(t)&&this.options.blocks.splice(this.options.blocks.indexOf(t),1)}blockGestures(){for(let t=0;t<this.options.blocks.length;t++){const e=this.options.blocks[t];e.state==s.Inactive&&(0==this.DEBUG&&console.log(`[Gesture] blocking ${e.eventBaseName}`),e.state=s.Blocked)}}unblockGestures(){for(let t=0;t<this.options.blocks.length;t++){this.options.blocks[t].state=s.Inactive}}getEventData(t){throw new Error("Gesture subclasses require a getEventData method()")}}class D extends E{constructor(t,e){super(t,e),this.initialPointerEvent=null,this.validPointerManagerState=o.SinglePointer;const i=this.getEmptyGestureParameters();this.initialParameters={...i},this.activeStateParameters=JSON.parse(JSON.stringify({...i}))}getEventData(t){const e=t.parameters.live,i=t.parameters.live;let n=e.vector,s=e.duration;if(null!=this.initialPointerEvent){const e=new h(this.initialPointerEvent.clientX,this.initialPointerEvent.clientY),i=new h(t.pointer.currentPointerEvent.clientX,t.pointer.currentPointerEvent.clientY);n=new u(e,i),s=t.pointer.currentPointerEvent.timeStamp-this.initialPointerEvent.timeStamp}return{recognizer:this,global:{deltaX:n.x,deltaY:n.y,distance:n.vectorLength,speedX:n.x/s,speedY:n.y/s,speed:n.vectorLength/s,direction:n.direction,scale:1,rotation:0,srcEvent:t.pointer.currentPointerEvent},live:{deltaX:i.vector.x,deltaY:i.vector.y,distance:i.vector.vectorLength,speedX:i.vector.x/t.pointer.vectorTimespan,speedY:i.vector.y/t.pointer.vectorTimespan,speed:i.speed,direction:i.vector.direction,scale:1,rotation:0,center:{x:i.vector.endPoint.x,y:i.vector.endPoint.y},srcEvent:t.pointer.currentPointerEvent}}}}class b extends D{constructor(t,e){super(t,e),this.validPointerManagerState=o.NoPointer,this.eventBaseName="tap";let i=200,n=30,s=30;e&&("maxDuration"in e&&(i=e.maxDuration),"maxDistance"in e&&(n=e.maxDistance,s=e.maxDistance)),this.initialParameters.global.max.duration=i,this.initialParameters.live.max.distance=n,this.initialParameters.global.max.distance=s}validate(t){let e=this.validateGestureState();if(1==e&&(e=this.validatePointerManagerState(t)),!0===e){if(1!=t.lastInputSessionPointerCount)return!1;{const i=t.getlastRemovedPointerInput();e=i instanceof p&&this.validateGestureParameters(i)}}return e}onStart(t){this.setInitialPointerEvent(t),this.emit(t)}}class I extends D{static minDuration=600;constructor(t,e){super(t,e),this.eventBaseName="press";let i=600,n=10,s=20;e&&("minDuration"in e&&(i=e.minDuration),"maxDistance"in e&&(s=e.maxDistance,n=e.maxDistance)),this.initialParameters.global.min.duration=i,this.initialParameters.global.max.distance=n,this.initialParameters.global.max.maximumDistance=s,this.hasBeenEmitted=!1}recognize(t){const e=this.validate(t),i=this.getPointerInput(t),n=this.initialParameters.global.min.duration||I.minDuration;if(i instanceof p)if(1==e&&0==this.hasBeenEmitted)this.setInitialPointerEvent(t),this.emit(t),this.hasBeenEmitted=!0,this.state=s.Active,this.blockGestures();else if(0==e&&1==this.hasBeenEmitted)this.onEnd(t),this.state=s.Inactive,this.hasBeenEmitted=!1;else{const t=i.parameters.global.duration;1==this.hasBeenEmitted&&t<=n&&(this.hasBeenEmitted=!1)}null==i&&(this.hasBeenEmitted=!1)}}class f extends D{constructor(t,e){super(t,e),this.validPointerManagerState=o.SinglePointer,this.eventBaseName="pan",this.initialParameters.global.min.duration=0,this.initialParameters.live.min.distance=10,this.initialParameters.global.boolean.hasBeenMoved=!0,this.swipeFinalSpeed=600,this.isSwipe=!1,this.options.supportedDirections=e?.supportedDirections??n.All,this.initialSupportedDirections=this.options.supportedDirections}validate(t){this.state==s.Active&&(this.options.supportedDirections=n.All);return super.validate(t)}onStart(t){this.isSwipe=!1,super.onStart(t)}onEnd(t){const i=t.getlastRemovedPointerInput();i instanceof p&&(this.swipeFinalSpeed<i.parameters.global.finalSpeed&&i.parameters.live.vector.direction!=e.None?(this.isSwipe=!0,this.emit(t,"swipe")):1==this.DEBUG&&(i.parameters.global.finalSpeed<this.swipeFinalSpeed?console.log(`[Pan] dismissing swipe. Final speed: ${i.parameters.global.finalSpeed} < ${this.swipeFinalSpeed}`):console.log(`[Pan] dismissing swipe. Direction: ${i.parameters.live.vector.direction}`))),super.onEnd(t),this.options.supportedDirections=this.initialSupportedDirections}onTouchMove(t){this.state==s.Active&&(1==this.DEBUG&&console.log("[Pan] preventing touchmove default"),t.preventDefault(),t.stopPropagation())}}class G{constructor(t,e){this.pointerIds=new Set([t.pointerId,e.pointerId]),this.startTimestamp=(new Date).getTime(),this.pointerMap={},this.pointerMap[t.pointerId]=t,this.pointerMap[e.pointerId]=e,this.pointer_1=t,this.pointer_2=e,this.initialPointerEvent=t.initialPointerEvent,this.currentPointerEvent=t.initialPointerEvent;const i=this.pointer_1.parameters.global.vector,n=this.pointer_2.parameters.global.vector,s={duration:0,center:v.getCenter(i.startPoint,n.startPoint),centerHasBeenMoved:!1,centerMovementDistance:0,centerMovementVector:v.getCenterMovementVector(i,n),absolutePointerDistanceChange:0,relativePointerDistanceChange:0,rotationAngle:0,absoluteRotationAngle:0,vectorAngle:0,absoluteVectorAngle:0},r=this.pointer_1.parameters.live.vector,o=this.pointer_2.parameters.live.vector,a={global:s,live:{center:v.getCenter(r.startPoint,o.startPoint),centerIsMoving:!1,centerMovementDistance:0,centerMovementVector:v.getCenterMovementVector(r,o),absolutePointerDistanceChange:0,relativePointerDistanceChange:0,rotationAngle:0,absoluteRotationAngle:0,vectorAngle:0,absoluteVectorAngle:0}};this.parameters=a}removePointer(t){if(t==this.pointer_1.pointerId)return this.pointer_2;if(t==this.pointer_2.pointerId)return this.pointer_1;throw new Error(`[DualPointerInput] cannot remove Pointer #${t}. The pointer is not part of this DualPointerInput`)}getTarget(){return this.initialPointerEvent.target}update(t){t instanceof PointerEvent&&(this.currentPointerEvent=t);const e=(new Date).getTime();this.parameters.global.duration=e-this.startTimestamp;const i=this.pointer_1.parameters.global.vector,n=this.pointer_2.parameters.global.vector,s=v.getCenter(i.startPoint,n.startPoint),r=v.getCenterMovementVector(i,n),o=v.calculateAbsoluteDistanceChange(i,n),a=v.calculateRelativeDistanceChange(i,n),l=v.calculateRotationAngle(i,n),c=v.calculateVectorAngle(i,n);this.parameters.global.center=s,this.parameters.global.centerMovementVector=r,this.parameters.global.centerMovementDistance=r.vectorLength,this.parameters.global.absolutePointerDistanceChange=o,this.parameters.global.relativePointerDistanceChange=a,this.parameters.global.rotationAngle=l,this.parameters.global.absoluteRotationAngle=Math.abs(l),this.parameters.global.vectorAngle=c,this.parameters.global.absoluteVectorAngle=Math.abs(c);const h=this.pointer_1.parameters.live.vector,u=this.pointer_2.parameters.live.vector,p=v.getCenter(h.startPoint,u.startPoint),d=v.getCenterMovementVector(h,u),m=v.calculateAbsoluteDistanceChange(h,u),g=v.calculateRelativeDistanceChange(h,u),P=v.calculateRotationAngle(h,u),E=v.calculateVectorAngle(h,u);d.vectorLength>0?(this.parameters.live.centerIsMoving=!0,this.parameters.global.centerHasBeenMoved=!0):this.parameters.live.centerIsMoving=!1,this.parameters.live.center=p,this.parameters.live.centerMovementDistance=d.vectorLength,this.parameters.live.centerMovementVector=d,this.parameters.live.absolutePointerDistanceChange=m,this.parameters.live.relativePointerDistanceChange=g,this.parameters.live.rotationAngle=P,this.parameters.live.absoluteRotationAngle=Math.abs(P),this.parameters.live.vectorAngle=E,this.parameters.live.absoluteVectorAngle=Math.abs(E)}onPointerMove(t){this.update(t)}onPointerUp(t){this.update(t)}onPointerLeave(t){this.update(t)}onPointerCancel(t){this.update(t)}onIdle(){this.update()}getCurrentDirection(){return this.parameters.live.centerMovementVector.direction}getCurrentPointerEvent(){return this.currentPointerEvent}}class M extends E{constructor(t,e){super(t,e),this.initialPointerEvent_1=null,this.initialPointerEvent_2=null,this.validPointerManagerState=o.DualPointer,this.validPointerInputConstructor=G;const i=this.getEmptyGestureParameters();this.initialParameters={...i},this.activeStateParameters=JSON.parse(JSON.stringify({...i}))}getEventData(t){const e=t.parameters.global,i=t.parameters.live;return{recognizer:this,global:{deltaX:e.centerMovementVector.x,deltaY:e.centerMovementVector.y,distance:e.centerMovementDistance,speedX:e.centerMovementVector.x/e.duration,speedY:e.centerMovementVector.y/e.duration,speed:e.centerMovementVector.vectorLength/e.duration,direction:e.centerMovementVector.direction,scale:e.relativePointerDistanceChange,rotation:e.rotationAngle,srcEvent:t.currentPointerEvent},live:{deltaX:i.centerMovementVector.x,deltaY:i.centerMovementVector.y,distance:i.centerMovementDistance,speedX:i.centerMovementVector.x/e.duration,speedY:i.centerMovementVector.y/e.duration,speed:i.centerMovementVector.vectorLength/e.duration,direction:i.centerMovementVector.direction,scale:i.relativePointerDistanceChange,rotation:i.rotationAngle,center:{x:i.centerMovementVector.startPoint.x,y:i.centerMovementVector.startPoint.y},srcEvent:t.currentPointerEvent}}}}class S extends M{constructor(t,e){super(t,e),this.eventBaseName="pinch",this.initialParameters.live.min.centerMovementDistance=0,this.initialParameters.live.max.centerMovementDistance=50,this.initialParameters.live.min.absolutePointerDistanceChange=5,this.initialParameters.live.max.absoluteRotationAngle=20,this.initialParameters.live.min.absoluteVectorAngle=10}}class B extends M{constructor(t,e){super(t,e),this.eventBaseName="rotate",this.initialParameters.live.min.centerMovementDistance=0,this.initialParameters.live.max.centerMovementDistance=50,this.initialParameters.live.max.absolutePointerDistanceChange=50,this.initialParameters.live.min.absoluteRotationAngle=5,this.activeStateParameters.live.min.absoluteRotationAngle=0}}class x extends M{constructor(t,e){super(t,e),this.eventBaseName="twofingerpan",this.initialParameters.live.min.centerMovementDistance=10,this.initialParameters.live.max.absolutePointerDistanceChange=50,this.initialParameters.live.max.absoluteVectorAngle=150,this.activeStateParameters.live.min.centerMovementDistance=0}}class C{constructor(t){t=t||{},this.options={DEBUG:!1,...t},this.DEBUG=this.options.DEBUG,this.state=o.NoPointer,this.activePointerInput=null,this.lastRemovedPointer=null,this.lastInputSessionPointerCount=0,this.pointerAllocation={},this.unusedPointers={},this.onSurfacePointers={}}addPointer(t){1==this.DEBUG&&console.log(`[PointerManager] adding Pointer #${t.pointerId.toString()}`);const e={DEBUG:this.DEBUG},i=new g(t,e);this.onSurfacePointers[i.pointerId]=i,null==this.activePointerInput?this.setActiveSinglePointerInput(i):this.activePointerInput instanceof p?this.setActiveDualPointerInput(this.activePointerInput.pointer,i):this.activePointerInput instanceof G&&(this.unusedPointers[i.pointerId]=i),this.lastInputSessionPointerCount=this.currentPointerCount()}removePointer(t){1==this.DEBUG&&(console.log(`[PointerManager] starting to remove Pointer #${t}`),console.log(`[PointerManager] state: ${this.state}`));const e=this.onSurfacePointers[t];if(this.lastRemovedPointer=e,delete this.onSurfacePointers[t],t in this.unusedPointers&&delete this.unusedPointers[t],this.activePointerInput instanceof G){if(this.activePointerInput.pointerIds.has(t)){1==this.DEBUG&&console.log(`[PointerManager] removing Pointer #${t} from DualPointerInput`);const e=this.activePointerInput.removePointer(t);this.activePointerInput=null;const i=this.getUnusedPointer();i instanceof g?this.setActiveDualPointerInput(e,i):this.setActiveSinglePointerInput(e)}}else if(this.activePointerInput instanceof p){if(1==this.DEBUG&&console.log(`[PointerManager] removing Pointer #${t} from SinglePointerInput`),this.activePointerInput=null,this.state=o.NoPointer,Object.keys(this.unusedPointers).length>0)throw this.unusedPointers={},new Error("[PointerManager] found unused Pointers although there should not be any");if(Object.keys(this.onSurfacePointers).length>0)throw this.onSurfacePointers={},new Error("[PointerManager] found onSurfacePointers although there should not be any")}1==this.DEBUG&&console.log(`[PointerManager] state: ${this.state}`)}setActiveSinglePointerInput(t){t.reset();const e=new p(t);this.activePointerInput=e,this.pointerAllocation[t.pointerId]=e,delete this.unusedPointers[t.pointerId],this.state=o.SinglePointer,1==this.DEBUG&&console.log(`[PointerManager] state: ${this.state}`)}setActiveDualPointerInput(t,e){t.reset(),e.reset();const i=new G(t,e);this.activePointerInput=i,this.pointerAllocation[t.pointerId]=i,this.pointerAllocation[e.pointerId]=i,delete this.unusedPointers[t.pointerId],delete this.unusedPointers[e.pointerId],this.state=o.DualPointer,1==this.DEBUG&&console.log(`[PointerManager] state: ${this.state}`)}hasPointersOnSurface(){return Object.keys(this.onSurfacePointers).length>0}currentPointerCount(){return Object.keys(this.onSurfacePointers).length}getUnusedPointer(){if(Object.keys(this.unusedPointers).length>0){return Object.values(this.unusedPointers)[0]}return null}getPointerFromId(t){return t in this.onSurfacePointers?this.onSurfacePointers[t]:null}getlastRemovedPointerInput(){return this.lastRemovedPointer instanceof g?this.pointerAllocation[this.lastRemovedPointer.pointerId]:null}onIdle(){for(const t in this.onSurfacePointers){this.onSurfacePointers[t].onIdle()}this.activePointerInput?.onIdle()}onPointerMove(t){const e=this.getPointerFromId(t.pointerId);e instanceof g&&e.onPointerMove(t),this.activePointerInput?.onPointerMove(t)}onPointerUp(t){1==this.DEBUG&&console.log("[PointerManager] pointerup detected");const e=this.getPointerFromId(t.pointerId);e instanceof g&&e.onPointerUp(t),this.activePointerInput?.onPointerUp(t),this.removePointer(t.pointerId)}onPointerCancel(t){1==this.DEBUG&&console.log("[PointerManager] pointercancel detected");const e=this.getPointerFromId(t.pointerId);e instanceof g&&e.onPointerCancel(t),this.activePointerInput?.onPointerCancel(t),this.removePointer(t.pointerId)}}const A=[b,I,f,S,B,x];class w{constructor(t,e){this.state=l.NoActiveGesture,this.activeGestures=[],this.hadActiveGestureDuringCurrentContact=!1,this.gestureEventHandlers={},this.lastRecognitionTimestamp=null,this.idleRecognitionIntervalId=null,this.pointerEventHandlers={},this.touchEventHandlers={},e=e||{},this.options={DEBUG:!1,DEBUG_GESTURES:!1,DEBUG_POINTERMANAGER:!1,bubbles:!0,handleTouchEvents:!0,consecutiveGestures:!0,simultaneousGestures:!0,supportedGestures:[],...e},this.DEBUG=this.options.DEBUG;const i=(e.supportedGestures??A).map((e=>{if("function"==typeof e){const i={bubbles:this.options.bubbles,DEBUG:this.options.DEBUG_GESTURES};return new e(t,i)}if("object"==typeof e)return e;throw new Error("unsupported gesture type: "+typeof e)}));this.supportedGestures=i,this.domElement=t;const n={DEBUG:this.options.DEBUG_POINTERMANAGER};this.pointerManager=new C(n),this.addPointerEventListeners(),this.addTouchEventListeners()}addPointerEventListeners(){const t=this.domElement,e=this.onPointerDown.bind(this),i=this.onPointerMove.bind(this),n=this.onPointerUp.bind(this),s=this.onPointerCancel.bind(this);t.addEventListener("pointerdown",e,{passive:!0}),t.addEventListener("pointermove",i,{passive:!0}),t.addEventListener("pointerup",n,{passive:!0}),t.addEventListener("pointercancel",s,{passive:!0}),this.pointerEventHandlers={pointerdown:e,pointermove:i,pointerup:n,pointercancel:s}}onPointerDown(t){1==this.DEBUG&&console.log("[PointerListener] pointerdown event detected"),this.domElement.setPointerCapture(t.pointerId),this.pointerManager.addPointer(t),this.options.pointerdown?.(t,this),null!=this.idleRecognitionIntervalId&&this.clearIdleRecognitionInterval(),this.idleRecognitionIntervalId=setInterval((()=>{this.onIdle()}),100)}onPointerMove(t){1==this.pointerManager.hasPointersOnSurface()&&(this.pointerManager.onPointerMove(t),this.recognizeGestures(),this.options.pointermove?.(t,this))}onPointerUp(t){1==this.DEBUG&&console.log("[PointerListener] pointerup event detected"),this.domElement.releasePointerCapture(t.pointerId),1==this.pointerManager.hasPointersOnSurface()&&(this.pointerManager.onPointerUp(t),this.recognizeGestures(),this.options.pointerup?.(t,this)),this.clearIdleRecognitionInterval()}onPointerCancel(t){this.domElement.releasePointerCapture(t.pointerId),1==this.DEBUG&&console.log("[PointerListener] pointercancel detected"),this.pointerManager.onPointerCancel(t),this.recognizeGestures(),this.clearIdleRecognitionInterval(),this.options.pointercancel?.(t,this)}removePointerEventListeners(){for(const t in this.pointerEventHandlers){const e=this.pointerEventHandlers[t];this.domElement.removeEventListener(t,e)}}addTouchEventListeners(){if(1==this.options.handleTouchEvents){const t=this.onTouchMove.bind(this);this.domElement.addEventListener("touchmove",t),this.touchEventHandlers.touchmove=t}}removeTouchEventListeners(){for(const t in this.touchEventHandlers){const e=this.touchEventHandlers[t];this.domElement.removeEventListener(t,e)}}onTouchMove(t){for(let e=0;e<this.supportedGestures.length;e++){this.supportedGestures[e].onTouchMove(t)}}onIdle(){if(0==this.pointerManager.hasPointersOnSurface())this.clearIdleRecognitionInterval();else{const t=(new Date).getTime();let e=null;null!=this.lastRecognitionTimestamp&&(e=t-this.lastRecognitionTimestamp),(null==e||e>100)&&(this.pointerManager.onIdle(),1==this.DEBUG&&console.log("[PointerListener] onIdle - running idle recognition"),this.recognizeGestures())}}clearIdleRecognitionInterval(){null!=this.idleRecognitionIntervalId&&(clearInterval(this.idleRecognitionIntervalId),this.idleRecognitionIntervalId=null)}recognizeGestures(){this.lastRecognitionTimestamp=(new Date).getTime();let t=this.supportedGestures;0==this.options.simultaneousGestures&&this.state==l.ActiveGesture||0==this.options.consecutiveGestures&&this.state==l.ActiveGesture?t=[this.activeGestures[0]]:0==this.options.consecutiveGestures&&this.state==l.NoActiveGesture&&1==this.hadActiveGestureDuringCurrentContact&&1==this.pointerManager.hasPointersOnSurface()&&(t=[]);for(let e=0;e<t.length;e++){const i=t[e];if(i.recognize(this.pointerManager),this.updateActiveGestures(i),0==this.options.simultaneousGestures&&this.state==l.ActiveGesture)break}1==this.DEBUG&&console.log(`[PointerListener] hadActiveGestureDuringCurrentContact: ${this.hadActiveGestureDuringCurrentContact}`),0==this.pointerManager.hasPointersOnSurface()&&(this.hadActiveGestureDuringCurrentContact=!1)}updateActiveGestures(t){if(t.state==s.Active)this.hadActiveGestureDuringCurrentContact=!0,this.activeGestures.indexOf(t)<0&&this.activeGestures.push(t);else{const e=this.activeGestures.indexOf(t);e>=0&&this.activeGestures.splice(e,1)}this.activeGestures.length>0?this.state=l.ActiveGesture:this.state=l.NoActiveGesture}parseEventsString(t){return t.trim().split(/\s+/g)}on(t,e){const i=this.parseEventsString(t);for(let t=0;t<i.length;t++){const n=i[t];n in this.gestureEventHandlers||(this.gestureEventHandlers[n]=[]),-1==this.gestureEventHandlers[n].indexOf(e)&&this.gestureEventHandlers[n].push(e),this.domElement.addEventListener(n,e,{capture:!1,passive:!0})}}off(t,e){const i=this.parseEventsString(t);1==this.DEBUG&&(console.log(`[PointerListener] turning off events: ${t}`),console.log(this.gestureEventHandlers));for(let t=0;t<i.length;t++){const n=i[t];if(n in this.gestureEventHandlers){const t=this.gestureEventHandlers[n],i=t.indexOf(e);1==this.DEBUG&&console.log(`[PointerListener] turning off ${n}. Index on handlerList: ${i}`),i>=0&&(t.splice(i,1),this.gestureEventHandlers[n]=t),this.domElement.removeEventListener(n,e,!1)}}}destroy(){for(const t in this.gestureEventHandlers){const e=this.gestureEventHandlers[t];for(let i=0;i<e.length;i++){const n=e[i];this.domElement.removeEventListener(t,n)}delete this.gestureEventHandlers[t]}this.removePointerEventListeners(),this.removeTouchEventListeners()}}
//# sourceMappingURL=index.js.map
