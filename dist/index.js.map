{"mappings":"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","sources":["src/input-consts.ts","src/geometry/Point.ts","src/geometry/Vector.ts","src/geometry/Geometry.ts","src/SinglePointerInput.ts","src/Pointer.ts","src/gestures/Gesture.ts","src/gestures/SinglePointerGesture.ts","src/gestures/Tap.ts","src/gestures/Press.ts","src/gestures/Pan.ts","src/DualPointerInput.ts","src/gestures/DualPointerGesture.ts","src/gestures/Pinch.ts","src/gestures/Rotate.ts","src/gestures/TwoFingerPan.ts","src/PointerManager.ts","src/PointerListener.ts"],"sourcesContent":["export enum Direction {\n  None = \"0\",\n  Left = \"left\",\n  Right = \"right\",\n  Up = \"up\",\n  Down = \"down\"\n}\n\nexport const Directions = Object.freeze({\n  Horizontal: [\n    Direction.Left,\n    Direction.Right\n  ],\n  Vertical: [\n    Direction.Up,\n    Direction.Down\n  ],\n  All: [\n    Direction.Left,\n    Direction.Right,\n    Direction.Up,\n    Direction.Down,\n    Direction.None,\n  ]\n});\n\nexport enum GestureState {\n  Inactive = \"inactive\",\n  Active = \"active\",\n  Blocked = \"blocked\"\n}\n\nexport enum PointerManagerState {\n  NoPointer = \"nopointer\",\n  SinglePointer = \"singlepointer\",\n  DualPointer = \"dualpointer\",\n}\n\nexport enum PointerListenerState {\n  NoActiveGesture = \"noactivegesture\",\n  ActiveGesture = \"activegesture\",\n}","export class Point {\n    public readonly x: number;\n    public readonly y: number;\n\n    public constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}","import { Point } from \"./Point\";\nimport { Direction } from \"../input-consts\";\n\n/*\n* important notice regarding the coordinate system on the screen:\n* - origin is the top-left corner\n* - downards from the origin on the y-axis are positive values\n*/\nexport class Vector {\n  public readonly vectorLength: number;\n\n  public readonly startPoint: Point;\n  public readonly endPoint: Point;\n\n  public readonly direction: Direction;\n\n  public readonly deltaX: number;\n  public readonly deltaY: number;\n\n  public readonly x: number;\n  public readonly y: number;\n\n  // vector between 2 points: START(x,y) and END(x,y)\n  public constructor(startPoint: Point, endPoint: Point) {\n    this.startPoint = startPoint;\n    this.endPoint = endPoint;\n\n    this.direction = Direction.None;\n\n    this.deltaX = this.endPoint.x - this.startPoint.x;\n    this.deltaY = this.endPoint.y - this.startPoint.y;\n\n    this.x = this.deltaX;\n    this.y = this.deltaY;\n\n    // determine length\n    this.vectorLength = Math.sqrt(\n      Math.pow(this.deltaX, 2) + Math.pow(this.deltaY, 2)\n    );\n\n    // determine direction\n    if (Math.abs(this.deltaX) > Math.abs(this.deltaY)) {\n      // left or right\n      if (this.startPoint.x < this.endPoint.x) {\n        this.direction = Direction.Right;\n      } else if (this.startPoint.x > this.endPoint.x) {\n        this.direction = Direction.Left;\n      }\n    } else {\n      // up or down\n      if (this.startPoint.y < this.endPoint.y) {\n        this.direction = Direction.Down;\n      } else if (this.startPoint.y > this.endPoint.y) {\n        this.direction = Direction.Up;\n      }\n    }\n  }\n}","import { Point } from \"./Point\";\nimport { Vector } from \"./Vector\";\n\nexport class Geometry {\n\n\tstatic getVector(startPointerEvent: PointerEvent, endPointerEvent: PointerEvent): Vector {\n\n\t\tconst startPoint = new Point(\n\t\t\tstartPointerEvent.clientX,\n\t\t\tstartPointerEvent.clientY\n\t\t);\n\n\t\tconst endPoint = new Point(\n\t\t\tendPointerEvent.clientX,\n\t\t\tendPointerEvent.clientY\n\t\t);\n\n\t\tconst vector = new Vector(startPoint, endPoint);\n\n\t\treturn vector;\n\t}\n\n\t// update speed. speed = distance / time\n\tstatic getSpeed(vector: Vector, startTimestamp: number, endTimestamp: number): number {\n\n\t\tlet speed = 0;\n\n\t\tconst timespan_ms = endTimestamp - startTimestamp;\n\t\tconst timespan_s = timespan_ms / 1000;\n\n\t\tif (vector != null && timespan_s != 0) {\n\t\t\t// px/s\n\t\t\tspeed = vector.vectorLength / timespan_s;\n\t\t}\n\n\t\treturn speed;\n\t}\n\n\t/*\n\t* CALCULATE ROTATION\n\t* this is not a trivial problem\n\t* required output is: angle and direction (cw //ccw)\n\t* direction is relative to the first touch with two fingers, not absolute to the screens default coordinate system\n\t* to determine rotation direction, 3 points on the circle - with timestamps - are required\n\t* imagine a steering wheel\n\t* - initial state is 0 deg (0)\n\t* - if the wheel has been turned ccw, its state has a negative angle\n\t* - if the wheel has been turned cw, its state has a positive angle\n\t* - possible values for the angle: [-360,360]\n\t*/\n\tstatic calculateRotationAngle(vector_1: Vector, vector_2: Vector): number {\n\t\t// vector_ are vectors between 2 points in time, same finger\n\t\t// angleAector_ are vectors between 2 fingers\n\t\tconst angleVector_1 = new Vector(vector_1.startPoint, vector_2.startPoint); // in time: occured first\n\t\tconst angleVector_2 = new Vector(vector_1.endPoint, vector_2.endPoint); // in time: occured second\n\n\t\tconst origin = new Point(0, 0);\n\n\t\t// translate the points of the vector, so that their startPoints are attached to (0,0)\n\t\t/*\n\n\t\t\t\t  ^\n\t\t\t\t /\n\t\t\t\t/\n\t\t\t   /\n\t\t\t  x\n\t\t\t  0\n\n\t\t*/\n\t\tconst translationVector_1 = new Vector(angleVector_1.startPoint, origin);\n\t\tconst translatedEndPoint_1 = this.translatePoint(\n\t\t\tangleVector_1.endPoint,\n\t\t\ttranslationVector_1\n\t\t);\n\n\t\t//var v_1_translated = new Vector(origin, translatedEndPoint_1);\n\n\t\tconst translationVector_2 = new Vector(angleVector_2.startPoint, origin);\n\t\tconst translatedEndPoint_2 = this.translatePoint(\n\t\t\tangleVector_2.endPoint,\n\t\t\ttranslationVector_2\n\t\t);\n\n\t\t//var v2_translated = new Vector(origin, translatedEndPoint_2);\n\n\t\t// rotate the first angle vector so its y-coordinate becomes 0\n\t\t/*\n\n\t\t\tx------->\n\t\t\t0\n\n\t\t*/\n\t\tconst rotationAngle = this.calcAngleRad(translatedEndPoint_1) * -1;\n\n\t\t// rottation matrix\n\t\t//var x_1_rotated =  ( translatedEndPoint_1.x * Math.cos(rotationAngle) ) - ( translatedEndPoint_1.y * Math.sin(rotationAngle) );\n\t\t//var y_1_rotated = Math.round(( translatedEndPoint_1.x * Math.sin(rotationAngle) ) + ( translatedEndPoint_1.y * Math.cos(rotationAngle) )); // should be 0\n\n\t\t//var v_1_rotated = new Vector(origin, new Point(x_1_rotated, y_1_rotated));\n\n\t\t// rotate the second vector (in time: after 1st)\n\t\tconst x_2_rotated =\n\t\t\ttranslatedEndPoint_2.x * Math.cos(rotationAngle) -\n\t\t\ttranslatedEndPoint_2.y * Math.sin(rotationAngle);\n\t\tconst y_2_rotated = Math.round(\n\t\t\ttranslatedEndPoint_2.x * Math.sin(rotationAngle) +\n\t\t\ttranslatedEndPoint_2.y * Math.cos(rotationAngle)\n\t\t);\n\n\t\t//var v_2_rotated = new Vector(origin, new Point(x_2_rotated, y_2_rotated));\n\n\t\t// calculate the angle between v_1 and v_2\n\n\t\tconst angleDeg = (Math.atan2(y_2_rotated, x_2_rotated) * 180) / Math.PI;\n\n\t\treturn angleDeg;\n\t}\n\n\tstatic calculateVectorAngle(vector_1: Vector, vector_2: Vector): number {\n\t\tlet angleDeg = 0;\n\n\t\tif (vector_1.vectorLength > 0 && vector_2.vectorLength > 0) {\n\t\t\tconst cos =\n\t\t\t\t(vector_1.x * vector_2.x + vector_1.y * vector_2.y) /\n\t\t\t\t(vector_1.vectorLength * vector_2.vectorLength);\n\n\t\t\tconst angleRad = Math.acos(cos);\n\t\t\tangleDeg = this.rad2deg(angleRad);\n\t\t}\n\n\t\treturn angleDeg;\n\t}\n\n\tstatic translatePoint(point: Point, vector: Vector): Point {\n\t\tconst newX = point.x + vector.x;\n\t\tconst newY = point.y + vector.y;\n\n\t\tconst translatedPoint = new Point(newX, newY);\n\t\treturn translatedPoint;\n\t}\n\n\t// return the counter-clockwise angle between the positive x-axis and a point.\n\t// from 0 degrees to 360 degrees\n\t// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2\n\tstatic calcAngleDegrees(point: Point): number {\n\t\t// angle in degrees between -180 and 180\n\t\tlet angle = (Math.atan2(point.y, point.x) * 180) / Math.PI;\n\n\t\tif (angle < 0) {\n\t\t\tangle = 360 + angle;\n\t\t}\n\n\t\treturn angle;\n\t}\n\n\tstatic calcAngleRad(point: Point): number {\n\t\tlet angle = Math.atan2(point.y, point.x); // [-PI, PI]\n\n\t\tif (angle < 0) {\n\t\t\tangle = 2 * Math.PI + angle;\n\t\t}\n\n\t\treturn angle;\n\t}\n\n\n\tstatic deg2rad(angleDeg: number): number {\n\t\tconst rad = (Math.PI / 180) * angleDeg;\n\t\treturn rad;\n\t}\n\n\tstatic rad2deg(angleRad: number): number {\n\t\tconst deg = angleRad / (Math.PI / 180);\n\t\treturn deg;\n\t}\n\n\t// DualPointerInput calculations\n\t// center between start points\n\n\tstatic getCenter(pointA: Point, pointB: Point): Point {\n\t\tconst centerX = (pointA.x + pointB.x) / 2;\n\t\tconst centerY = (pointA.y + pointB.y) / 2;\n\n\t\tconst center = new Point(centerX, centerY);\n\t\treturn center;\n\t}\n\n\tstatic getCenterMovementVector(vector_1: Vector, vector_2: Vector): Vector {\n\n\t\t// start point is the center between the starting points of the 2 vectors\n\t\tconst startPoint = this.getCenter(vector_1.startPoint, vector_2.startPoint);\n\n\t\t// center between the end points of the vectors\n\t\tconst endPoint = this.getCenter(vector_1.endPoint, vector_2.endPoint);\n\n\t\tconst vectorBetweenCenterPoints = new Vector(startPoint, endPoint);\n\n\t\treturn vectorBetweenCenterPoints;\n\t}\n\n\tstatic calculateAbsoluteDistanceChange(vector_1: Vector, vector_2: Vector): number {\n\t\tconst vectorBetweenStartPoints = new Vector(\n\t\t\tvector_1.startPoint,\n\t\t\tvector_2.startPoint\n\t\t);\n\t\tconst vectorBetweenEndPoints = new Vector(\n\t\t\tvector_1.endPoint,\n\t\t\tvector_2.endPoint\n\t\t);\n\n\t\tconst absoluteDistanceChange =\n      vectorBetweenEndPoints.vectorLength -\n      vectorBetweenStartPoints.vectorLength;\n\n    return absoluteDistanceChange;\n\t}\n\n\tstatic calculateRelativeDistanceChange(vector_1: Vector, vector_2: Vector): number {\n\n    const vectorBetweenStartPoints = new Vector(\n\t\t\tvector_1.startPoint,\n\t\t\tvector_2.startPoint\n\t\t);\n\t\tconst vectorBetweenEndPoints = new Vector(\n\t\t\tvector_1.endPoint,\n\t\t\tvector_2.endPoint\n\t\t);\n\n\t\tconst relativeDistanceChange =\n\t\t\tvectorBetweenEndPoints.vectorLength /\n\t\t\tvectorBetweenStartPoints.vectorLength;\n\n\t\treturn relativeDistanceChange;\n\t}\n\n}","import { Pointer } from \"./Pointer\";\nimport { PointerParameters } from \"./interfaces\";\n\nexport class SinglePointerInput {\n\n  pointer: Pointer;\n  readonly parameters: PointerParameters;\n\n  constructor(pointer: Pointer) {\n    this.pointer = pointer;\n    this.parameters = pointer.parameters;\n  }\n\n  getTarget(): EventTarget | null {\n    return this.pointer.initialPointerEvent.target;\n  }\n\n  getCurrentPointerEvent(): PointerEvent {\n    return this.pointer.currentPointerEvent;\n  }\n\n  // string is not good, it should be Direction\n  getCurrentDirection() : string {\n    return this.parameters.live.vector.direction;\n  }\n\n  onIdle(): void { }\n\n  onPointerMove(pointermoveEvent: PointerEvent): void { }\n\n  onPointerUp(pointerupEvent: PointerEvent): void { }\n\n  onPointerLeave(pointerleaveEvent: PointerEvent): void { }\n\n  onPointerCancel(pointercancelEvent: PointerEvent): void { }\n}","import { Geometry } from \"./geometry/Geometry\";\nimport {\n  PointerGlobalParameters,\n  PointerLiveParameters,\n  PointerParameters,\n} from \"./interfaces\";\n\n/*********************************************************************************************************************\n  PointerInput\n\n  - contains data about one single finger / pointer\n  - there are \"live\" parameters and \"global\" parameters\n  - \"live\" parameters are caluclated using liveTimespan\n  - \"global\" parameters are calculated using the whole timespan of this pointerdown\n  - the current vector. The vector should be calculated \"live\" and not over the whole pointerdown duration.\n  The user expects the pointer input to be in sync with his current finger movement on the screen,\n  not with something a second ago.\n  - start and end coordinates\n  - start and end timestamps\n  - speeds and distances\n********************************************************************************************************************/\n\ninterface PointerOptions {\n  DEBUG: boolean;\n  vectorTimespan?: number;\n}\n\nenum PointerState {\n  Active = \"active\", // on the surface\n  Removed = \"removed\", // removed from surface\n  Canceled = \"canceled\",\n}\n\n\nexport class Pointer {\n  readonly options: PointerOptions;\n  DEBUG: boolean;\n  vectorTimespan: number;\n\n  readonly pointerId: number;\n\n  readonly parameters: PointerParameters;\n\n  readonly initialPointerEvent: PointerEvent;\n  currentPointerEvent: PointerEvent;\n  recognizedEvents: PointerEvent[];\n\n  state: PointerState;\n\n  constructor(pointerEvent: PointerEvent, options?: PointerOptions) {\n\n    this.options = {\n      DEBUG: false,\n      ...options,\n    };\n\n    this.DEBUG = this.options.DEBUG;\n\n    const now = new Date().getTime();\n\n    this.pointerId = pointerEvent.pointerId;\n    this.vectorTimespan = this.options.vectorTimespan ?? 100; // milliseconds\n\n    this.initialPointerEvent = pointerEvent;\n    this.currentPointerEvent = pointerEvent;\n    this.recognizedEvents = [pointerEvent];\n\n    this.state = PointerState.Active;\n\n    const nullVector = Geometry.getVector(pointerEvent, pointerEvent);\n\n    const globalParameters: PointerGlobalParameters = {\n      startX: this.initialPointerEvent.clientX,\n      startY: this.initialPointerEvent.clientY,\n      vector: nullVector,\n      deltaX: 0,\n      deltaY: 0,\n      startTimestampUTC: now,\n      startTimestamp: this.initialPointerEvent.timeStamp, // unfortunately, FF (linux) does not provide UTC, but elapsed time since the window Object was created\n      currentTimestamp: this.initialPointerEvent.timeStamp,\n      endTimestamp: null,\n      maximumSpeed: 0,\n      currentSpeed: 0,\n      distance: 0,\n      maximumDistance: 0,\n      averageSpeed: 0,\n      finalSpeed: 0,\n      traveledDistance: 0,\n      hasBeenMoved: false,\n      duration: 0,\n    };\n\n    const liveParameters: PointerLiveParameters = {\n      duration: 0, // ms\n      speed: 0,\n      vector: nullVector,\n      distance: 0,\n      isMoving: false,\n    };\n\n    const parameters: PointerParameters = {\n      global: globalParameters,\n      live: liveParameters,\n    };\n\n    this.parameters = parameters;\n\n  }\n\n  getTarget(): EventTarget | null {\n    return this.initialPointerEvent.target;\n  }\n\n  reset(): void {\n\n  }\n\n  onIdle(): void {\n    const now = new Date().getTime();\n\n    // currentTimestamp is not an UTC millisecond timestamp.\n    // this.globalParameters.currentTimestamp = now;\n\n    const duration = now - this.parameters.global.startTimestampUTC;\n    this.parameters.global.duration = duration;\n  }\n\n  onPointerMove(pointermoveEvent: PointerEvent): void {\n\n    this.parameters.global.hasBeenMoved = true;\n    this.parameters.live.isMoving = true;\n\n    this.update(pointermoveEvent);\n  }\n\n  onPointerUp(pointerupEvent: PointerEvent): void {\n    this.parameters.global.finalSpeed = this.parameters.live.speed;\n\n    this.parameters.live.speed = 0;\n\n    this.parameters.live.isMoving = false;\n    this.state = PointerState.Removed;\n\n    this.parameters.global.endTimestamp = pointerupEvent.timeStamp;\n\n    this.update(pointerupEvent);\n\n    if (this.DEBUG === true) {\n      console.log(\n        `[PointerInput] pointerdown ended. pointerdown duration: ${this.parameters.global.duration}ms`\n      );\n    }\n  }\n\n  onPointerLeave(pointerleaveEvent: PointerEvent): void {\n    this.onPointerUp(pointerleaveEvent);\n  }\n\n  onPointerCancel(pointercancelEvent: PointerEvent): void {\n    this.update(pointercancelEvent);\n\n    this.parameters.live.speed = 0;\n\n    this.state = PointerState.Canceled;\n\n    this.parameters.live.isMoving = false;\n\n    this.parameters.global.endTimestamp = pointercancelEvent.timeStamp;\n\n    if (this.DEBUG === true) {\n      console.log(`[PointerInput] canceled, pointerdown duration:${this.parameters.global.duration}ms`);\n    }\n  }\n\n  update(pointerEvent: PointerEvent): void {\n    // update general parameters\n    this.currentPointerEvent = pointerEvent;\n    this.recognizedEvents.push(pointerEvent);\n\n    // update liveParameters\n    // maybe check if clientX and clientY are present\n\n    const timedPointerEvents = this.getTimedPointerEvents();\n\n    const liveVector = Geometry.getVector(\n      timedPointerEvents[0],\n      timedPointerEvents[1]\n    );\n\n    this.parameters.live.vector = liveVector;\n    this.parameters.live.distance = liveVector.vectorLength;\n\n    this.parameters.live.speed = Geometry.getSpeed(\n      liveVector,\n      timedPointerEvents[0].timeStamp,\n      timedPointerEvents[1].timeStamp\n    );\n\n    // update global parameters\n    if (this.parameters.live.speed > this.parameters.global.maximumSpeed) {\n      this.parameters.global.maximumSpeed = this.parameters.live.speed;\n    }\n    this.parameters.global.currentTimestamp = pointerEvent.timeStamp;\n    this.parameters.global.duration = pointerEvent.timeStamp - this.parameters.global.startTimestamp;\n\n    this.parameters.global.deltaX = liveVector.endPoint.x - this.parameters.global.startX;\n    this.parameters.global.deltaY = liveVector.endPoint.y - this.parameters.global.startY;\n\n    const globalVector = Geometry.getVector(\n      this.initialPointerEvent,\n      this.currentPointerEvent\n    );\n    this.parameters.global.vector = globalVector;\n\n    this.parameters.global.distance = globalVector.vectorLength;\n    if (globalVector.vectorLength > this.parameters.global.maximumDistance) {\n      this.parameters.global.maximumDistance = globalVector.vectorLength;\n    }\n\n    if (this.DEBUG === true) {\n      console.log(\n        `[PointerInput] current speed: ${this.parameters.live.speed}px/s`\n      );\n      console.log(\n        `[PointerInput] pointerdown duration: ${this.parameters.global.duration}ms`\n      );\n\n      console.log(\n        `[PointerInput] live vector length within vectorTimespan: ${this.parameters.live.vector.vectorLength}px`\n      );\n    }\n\n  }\n\n  /*\n   * Get the two events which are necessary for vector calculation. This is based on this.vectorTimespan.\n   * vectorTimespan defines the timespan which actually defines the \"live\" vector\n   */\n  private getTimedPointerEvents(): PointerEvent[] {\n    // if the duration is lower than the vectorTimespan, startPointerEvent would be null\n    // if so, use this.initialPointerEvent as a fallback\n    let startPointerEvent = this.initialPointerEvent;\n    const endPointerEvent =\n      this.recognizedEvents[this.recognizedEvents.length - 1];\n\n    let startIndex = this.recognizedEvents.length - 1;\n\n    let elapsedTime = 0;\n    const endTimeStamp = endPointerEvent.timeStamp;\n\n    while (elapsedTime < this.vectorTimespan) {\n      startIndex = startIndex - 1;\n\n      if (startIndex < 0) {\n        break;\n      }\n\n      startPointerEvent = this.recognizedEvents[startIndex];\n\n      elapsedTime = endTimeStamp - startPointerEvent.timeStamp;\n    }\n\n    const pointerEvents = [startPointerEvent, endPointerEvent];\n\n    this.recognizedEvents = this.recognizedEvents.slice(-20);\n\n    return pointerEvents;\n  }\n\n}","import { PointerManager } from \"../PointerManager\";\nimport { SinglePointerInput } from \"../SinglePointerInput\";\nimport { DualPointerInput } from \"../DualPointerInput\";\nimport { Pointer } from \"../Pointer\";\nimport { Point } from \"../geometry/Point\";\nimport { Vector } from \"../geometry/Vector\";\n\nimport {\n  TimedParameters,\n  TimedMinMaxParameters,\n  SinglePointerGestureParameters,\n  DualPointerGestureParameters,\n} from \"../interfaces\";\n\nimport {\n  GestureState,\n  PointerManagerState,\n  Direction,\n} from \"../input-consts\";\n\n\ntype GestureParameterValue = number | boolean | null | Vector;\n\ntype SinglePointerInputConstructor = new (...args: ConstructorParameters<typeof SinglePointerInput>) => SinglePointerInput;\ntype DualPointerInputConstructor = new (...args: ConstructorParameters<typeof DualPointerInput>) => DualPointerInput;\n\nexport const GestureEvent = CustomEvent<GestureEventData>;\n\nexport interface GestureOptions {\n  DEBUG: boolean;\n  blocks: Gesture[];\n  bubbles: boolean;\n  supportedDirections: string[];\n}\n\nexport interface GlobalGestureEventData {\n  deltaX: number;\n  deltaY: number;\n  distance: number;\n  speedX: number;\n  speedY: number;\n  speed: number;\n  direction: Direction;\n  scale: number;\n  rotation: number;\n  srcEvent: PointerEvent;\n}\n\nexport interface LiveGestureEventData {\n  deltaX: number;\n  deltaY: number;\n  distance: number;\n  speedX: number;\n  speedY: number;\n  speed: number;\n  direction: Direction;\n  scale: number;\n  rotation: number;\n  center: Point;\n  srcEvent: PointerEvent;\n}\n\nexport interface GestureEventData extends TimedParameters {\n  recognizer: Gesture,\n  global: GlobalGestureEventData,\n  live: LiveGestureEventData,\n}\n\nexport abstract class Gesture {\n\n  validPointerManagerState: PointerManagerState | null;\n  validPointerInputConstructor: SinglePointerInputConstructor | DualPointerInputConstructor;\n\n  options: GestureOptions;\n  DEBUG: boolean;\n\n  eventBaseName!: string;\n\n  readonly domElement: HTMLElement;\n\n  initialPointerEvent: PointerEvent | null;\n\n  initialParameters: SinglePointerGestureParameters | DualPointerGestureParameters | null;\n  activeStateParameters: SinglePointerGestureParameters | DualPointerGestureParameters | null;\n\n  state: GestureState;\n\n  constructor(domElement: HTMLElement, options?: Partial<GestureOptions>) {\n\n    this.state = GestureState.Inactive;\n\n    this.validPointerManagerState = null;\n    this.validPointerInputConstructor = SinglePointerInput;\n\n    this.domElement = domElement;\n\n    this.initialPointerEvent = null;\n\n    this.initialParameters = null;\n    this.activeStateParameters = null;\n\n    this.options = {\n      bubbles: true,\n      blocks: [],\n      supportedDirections: [],\n      DEBUG: false,\n      ...options\n    };\n\n    this.DEBUG = this.options.DEBUG;\n\n  }\n\n  getEmptyGestureParameters(): TimedMinMaxParameters {\n    const nullRecognitionParameters: TimedMinMaxParameters = {\n      global: {\n        min: {},\n        max: {},\n        boolean: {},\n      },\n\n      live: {\n        min: {},\n        max: {},\n        boolean: {},\n      }\n    };\n\n    return nullRecognitionParameters;\n  }\n\n  getGestureParameters(): SinglePointerGestureParameters | DualPointerGestureParameters {\n    let gestureParameters;\n\n    if (this.state == GestureState.Active) {\n      gestureParameters = this.activeStateParameters;\n      if (this.DEBUG == true) {\n        console.log(\n          `[${this.eventBaseName}] validating using activeStateParameters`\n        );\n        console.log(gestureParameters);\n      }\n    } else {\n      if (this.DEBUG == true) {\n        console.log(\n          `[${this.eventBaseName}] validating using initialParameters`\n        );\n      }\n      gestureParameters = this.initialParameters;\n    }\n\n    if (gestureParameters == null) {\n      throw new Error(\"[Gesture] no gesture parameters found. Do not call .getGestureParameters on abstract class Gesture\");\n    }\n\n    return gestureParameters;\n  }\n\n  validateGestureParameters(pointerInput: SinglePointerInput | DualPointerInput): boolean {\n\n    const gestureParameters = this.getGestureParameters();\n\n    let isValid = true;\n    let timespan: keyof typeof gestureParameters;\n    for (timespan in gestureParameters) {\n\n      const timedGestureParameters = gestureParameters[timespan];\n      const timedPointerInputValues = pointerInput.parameters[timespan] as Record<string, any>;\n\n      let minOrMaxOrBoolean: keyof typeof timedGestureParameters;\n\n      for (minOrMaxOrBoolean in timedGestureParameters) {\n        const evaluationParameters = timedGestureParameters[minOrMaxOrBoolean] as Record<string, GestureParameterValue>;\n        let gestureParameterName: string;\n        for (gestureParameterName in evaluationParameters) {\n          const gestureParameter = evaluationParameters[gestureParameterName];\n\n          const pointerInputValue = gestureParameterName.startsWith(\"absolute\") ? Math.abs(timedPointerInputValues[gestureParameterName]) : timedPointerInputValues[gestureParameterName];\n\n          if (this.DEBUG == true) {\n            console.log(\n              `[${this.eventBaseName}] validating ${timespan} ${minOrMaxOrBoolean}: required: ${gestureParameter}, pointer: ${pointerInputValue}`\n            );\n          }\n\n          if (typeof gestureParameter == \"boolean\" && typeof pointerInputValue == \"boolean\") {\n            isValid = this.validateBooleanParameter(gestureParameter, pointerInputValue);\n          }\n          else if (typeof gestureParameter == \"number\" && typeof pointerInputValue == \"number\") {\n            isValid = this.validateMinMaxParameter(gestureParameter, pointerInputValue, minOrMaxOrBoolean);\n          }\n\n          if (isValid == false) {\n            if (this.DEBUG == true) {\n              console.log(`[${this.eventBaseName}] invalidated `);\n            }\n            return false;\n          }\n\n        }\n      }\n    }\n\n    return true;\n  }\n\n  validateBooleanParameter(gestureParameter: boolean, pointerInputValue: boolean): boolean {\n    if (gestureParameter == null) {\n      return true;\n    } else if (gestureParameter == pointerInputValue) {\n\n      if (this.DEBUG == true) {\n        console.log(\n          `validated: required value: ${gestureParameter}, current value: ${pointerInputValue}`\n        );\n      }\n\n      return true;\n    }\n\n    if (this.DEBUG == true) {\n      console.log(\n        `dismissing ${this.eventBaseName}: required value: ${gestureParameter}, current value: ${pointerInputValue}`\n      );\n    }\n\n    return false;\n  }\n\n  validateMinMaxParameter(gestureParameter: number, pointerInputValue: number, minOrMax: string): boolean {\n    if (minOrMax == \"min\") {\n      if (pointerInputValue >= gestureParameter) {\n        return true;\n      }\n    }\n    else if (minOrMax == \"max\") {\n      if (pointerInputValue <= gestureParameter) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  validateDirection(pointerInput: SinglePointerInput | DualPointerInput): boolean {\n\n    const currentDirection = pointerInput.getCurrentDirection();\n\n    if (\n      this.options.supportedDirections.length &&\n      !this.options.supportedDirections.includes(\n        currentDirection\n      )\n    ) {\n      if (this.DEBUG == true) {\n        console.log(\n          `[Gestures] dismissing ${this.eventBaseName}: supported directions: ${this.options.supportedDirections}, current direction: ${currentDirection}`\n        );\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  validateGestureState(): boolean {\n    if (this.state == GestureState.Blocked) {\n      return false;\n    }\n    return true;\n  }\n\n  validatePointerManagerState(pointerManager: PointerManager): boolean {\n    if (pointerManager.state == this.validPointerManagerState) {\n      return true;\n    }\n\n    if (this.DEBUG == true) {\n      console.log(\n        `[Gesture] PointerManagerState invalidated ${this.eventBaseName}: ${pointerManager.state}`\n      );\n    }\n\n    return false;\n  }\n\n  validatePointerInputConstructor(pointerInput: SinglePointerInput | DualPointerInput): boolean {\n    if (pointerInput instanceof this.validPointerInputConstructor) {\n      return true;\n    }\n\n    if (this.DEBUG == true) {\n      console.log(\n        `[Gesture] PointerInputConstructor invalidated ${this.eventBaseName}: ${this.validPointerInputConstructor}`\n      );\n    }\n\n    return false;\n  }\n\n  // validate pointerCount and GestureState.Blocked\n  validate(pointerManager: PointerManager): boolean {\n\n    let isValid = this.validateGestureState();\n\n    if (isValid == true) {\n      isValid = this.validatePointerManagerState(pointerManager);\n    }\n\n    const pointerInput = pointerManager.activePointerInput;\n\n    if (\n      isValid == true &&\n      pointerInput != null\n    ) {\n      isValid = this.validatePointerInputConstructor(pointerInput);\n\n      if (isValid == true) {\n        isValid = this.validateDirection(pointerInput);\n      }\n\n      if (isValid == true) {\n        isValid = this.validateGestureParameters(pointerInput);\n      }\n    }\n\n    return isValid;\n  }\n\n  recognize(pointerManager: PointerManager): void {\n    const isValid = this.validate(pointerManager);\n\n    if (\n      isValid == true &&\n      this.state == GestureState.Inactive\n    ) {\n      this.onStart(pointerManager);\n    }\n\n    if (\n      isValid == true &&\n      this.state == GestureState.Active\n    ) {\n\n      if (this.initialPointerEvent == null) {\n        this.setInitialPointerEvent(pointerManager);\n      }\n\n      this.emit(pointerManager);\n\n    } else if (this.state == GestureState.Active && isValid == false) {\n\n      this.onEnd(pointerManager);\n\n    }\n    else {\n      if (this.DEBUG == true) {\n        console.log(\n          `not firing event ${this.eventBaseName}. No SinglePointerInput found`\n        );\n      }\n    }\n  }\n\n  /*\n   * The PointerInput for recognition has to be pointerManager.lastRemovedPointer if there is no active pointer left\n   */\n  getPointerInput(pointerManager: PointerManager): SinglePointerInput | DualPointerInput | null {\n\n    if (pointerManager.hasPointersOnSurface() == true && pointerManager.activePointerInput instanceof this.validPointerInputConstructor) {\n      return pointerManager.activePointerInput;\n    }\n    else if (pointerManager.lastRemovedPointer instanceof Pointer) {\n      const pointerInput = pointerManager.getlastRemovedPointerInput();\n      if (pointerInput instanceof this.validPointerInputConstructor) {\n        return pointerInput;\n      }\n    }\n\n    return null;\n  }\n\n  setInitialPointerEvent(pointerManager: PointerManager): void {\n    const pointerInput = this.getPointerInput(pointerManager);\n    if (pointerInput instanceof this.validPointerInputConstructor) {\n      const pointerEvent: PointerEvent = pointerInput.getCurrentPointerEvent();\n      this.initialPointerEvent = pointerEvent;\n    }\n  }\n\n  emit(pointerManager: PointerManager, eventName?: string): void {\n\n    // fire general event like \"tap\", \"press\", \"pan\"\n    eventName = eventName || this.eventBaseName;\n\n    if (this.DEBUG === true) {\n      console.log(`[Gestures] detected and firing event ${eventName}`);\n    }\n\n    const pointerInput = this.getPointerInput(pointerManager);\n\n    if (pointerInput != null) {\n\n      const target = pointerInput.getTarget();\n\n      if (target instanceof EventTarget) {\n\n        const eventData = this.getEventData(pointerInput);\n\n        const eventOptions = {\n          detail: eventData,\n          bubbles: this.options.bubbles,\n        };\n\n        const event = new GestureEvent(eventName, eventOptions);\n\n        if (eventOptions.bubbles == true) {\n          target.dispatchEvent(event);\n        } else {\n          this.domElement.dispatchEvent(event);\n        }\n\n        // fire direction specific events\n        const currentDirection = eventData.live.direction;\n\n        const hasSupportedDirections = !!this.options.supportedDirections;\n        // do not fire events like \"panendleft\"\n        // only fire directional events if eventName == this.eventBaseName\n        if (hasSupportedDirections == true && currentDirection != Direction.None && (eventName == this.eventBaseName || eventName == \"swipe\")) {\n          for (let d = 0; d < this.options.supportedDirections.length; d++) {\n            const direction = this.options.supportedDirections[d];\n\n            if (direction == currentDirection) {\n              const directionEventName = eventName + direction;\n\n              if (this.DEBUG == true) {\n                console.log(\n                  `[Gestures] detected and firing event ${directionEventName}`\n                );\n              }\n\n              const directionEvent = new CustomEvent(\n                directionEventName,\n                eventOptions\n              );\n\n              if (eventOptions.bubbles == true) {\n                target.dispatchEvent(directionEvent);\n              } else {\n                this.domElement.dispatchEvent(directionEvent);\n              }\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n  onStart(pointerManager: PointerManager): void {\n    this.blockGestures();\n\n    this.state = GestureState.Active;\n    this.setInitialPointerEvent(pointerManager);\n    const eventName = `${this.eventBaseName}start`;\n    this.emit(pointerManager, eventName);\n  }\n\n  onEnd(pointerManager: PointerManager): void {\n    this.unblockGestures();\n\n    if (this.DEBUG == true) {\n      console.log(`[${this.eventBaseName}] ended. Setting ${this.eventBaseName}.state = ${GestureState.Inactive}`);\n    }\n    this.state = GestureState.Inactive;\n\n    const eventName = `${this.eventBaseName}end`;\n    this.emit(pointerManager, eventName);\n\n  }\n\n  // provide the ability to react (eg block) to touch events\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  onTouchStart(event: TouchEvent): void { /* empty */ }\n  onTouchMove(event: TouchEvent): void { /* empty */ }\n  onTouchEnd(event: TouchEvent): void { /* empty */ }\n  onTouchCancel(event: TouchEvent): void { /* empty */ }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  block(gesture: Gesture): void {\n    if (this.options.blocks.indexOf(gesture) == -1) {\n      this.options.blocks.push(gesture);\n    }\n  }\n\n  unblock(gesture: Gesture): void {\n    if (this.options.blocks.indexOf(gesture) != -1) {\n      this.options.blocks.splice(this.options.blocks.indexOf(gesture), 1);\n    }\n  }\n\n  blockGestures(): void {\n    for (let g = 0; g < this.options.blocks.length; g++) {\n      const gesture = this.options.blocks[g];\n      if (gesture.state == GestureState.Inactive) {\n        if (this.DEBUG == false) {\n          console.log(\n            `[Gesture] blocking ${gesture.eventBaseName}`\n          );\n        }\n        gesture.state = GestureState.Blocked;\n      }\n    }\n  }\n\n  unblockGestures(): void {\n    for (let g = 0; g < this.options.blocks.length; g++) {\n      const gesture = this.options.blocks[g];\n      gesture.state = GestureState.Inactive;\n    }\n  }\n\n  getEventData(pointerInput: SinglePointerInput | DualPointerInput): GestureEventData {\n    throw new Error(\"Gesture subclasses require a getEventData method()\");\n  }\n\n}\n","import {\n  Gesture,\n  GestureOptions,\n  LiveGestureEventData,\n  GlobalGestureEventData,\n  GestureEventData,\n} from \"./Gesture\";\n\nimport { PointerManagerState } from \"../input-consts\";\nimport { SinglePointerGestureParameters } from \"../interfaces\";\nimport { Point } from \"../geometry/Point\";\nimport { Vector } from \"../geometry/Vector\";\nimport { SinglePointerInput } from \"../SinglePointerInput\";\n\nexport abstract class SinglePointerGesture extends Gesture {\n\n  initialPointerEvent: PointerEvent | null;\n\n  initialParameters: SinglePointerGestureParameters;\n  activeStateParameters: SinglePointerGestureParameters;\n\n  constructor(domElement: HTMLElement, options?: Partial<GestureOptions>) {\n    super(domElement, options);\n    this.initialPointerEvent = null;\n    this.validPointerManagerState = PointerManagerState.SinglePointer;\n\n    const nullRecognitionParameters = this.getEmptyGestureParameters() as SinglePointerGestureParameters;\n\n    this.initialParameters = { ...nullRecognitionParameters };\n    // a deep copy of the parameters is needed as they can have different values\n    this.activeStateParameters = JSON.parse(JSON.stringify({ ...nullRecognitionParameters }));\n  }\n\n  getEventData(singlePointerInput: SinglePointerInput): GestureEventData {\n    // provide short-cuts to the values collected in the Contact object\n    // match this to the event used by hammer.js\n\n    const globalParameters = singlePointerInput.parameters.live;\n    const liveParameters = singlePointerInput.parameters.live;\n\n    let globalVector: Vector = globalParameters.vector;\n    let globalDuration: number = globalParameters.duration;\n\n    // gesture specific - dependant on the beginning of the gesture (when the gesture has initially been recognized)\n    if (this.initialPointerEvent != null) {\n      const globalStartPoint = new Point(\n        this.initialPointerEvent.clientX,\n        this.initialPointerEvent.clientY\n      );\n      const globalEndPoint = new Point(\n        singlePointerInput.pointer.currentPointerEvent.clientX,\n        singlePointerInput.pointer.currentPointerEvent.clientY\n      );\n      globalVector = new Vector(globalStartPoint, globalEndPoint);\n      globalDuration =\n        singlePointerInput.pointer.currentPointerEvent.timeStamp -\n        this.initialPointerEvent.timeStamp;\n    }\n\n    // global: global for this recognizer, not the Contact object\n    const globalGestureEventData: GlobalGestureEventData = {\n      deltaX: globalVector.x,\n      deltaY: globalVector.y,\n      distance: globalVector.vectorLength,\n      speedX: globalVector.x / globalDuration,\n      speedY: globalVector.y / globalDuration,\n      speed: globalVector.vectorLength / globalDuration,\n      direction: globalVector.direction,\n      scale: 1,\n      rotation: 0,\n      srcEvent: singlePointerInput.pointer.currentPointerEvent,\n    };\n\n    const liveGestureEventData: LiveGestureEventData = {\n      deltaX: liveParameters.vector.x,\n      deltaY: liveParameters.vector.y,\n      distance: liveParameters.vector.vectorLength,\n      speedX:\n        liveParameters.vector.x / singlePointerInput.pointer.vectorTimespan,\n      speedY:\n        liveParameters.vector.y / singlePointerInput.pointer.vectorTimespan,\n      speed: liveParameters.speed,\n      direction: liveParameters.vector.direction,\n      scale: 1,\n      rotation: 0,\n      center: {\n        x: liveParameters.vector.endPoint.x,\n        y: liveParameters.vector.endPoint.y,\n      },\n      srcEvent: singlePointerInput.pointer.currentPointerEvent /*,\n      target : primaryPointerInput.touch.target,\n      pointerType : ,\n      eventType : ,\n      isFirst : ,\n      isFinal :,\n      pointers : ,*/,\n    };\n\n    const eventData: GestureEventData = {\n      recognizer: this,\n      global: globalGestureEventData,\n      live: liveGestureEventData,\n    };\n\n    return eventData;\n  }\n\n}","import { GestureOptions } from \"./Gesture\";\nimport { SinglePointerGesture } from \"./SinglePointerGesture\";\nimport { PointerManager } from \"../PointerManager\";\nimport { SinglePointerInput } from \"../SinglePointerInput\";\nimport { PointerManagerState } from \"../input-consts\";\n\n\ninterface TapOptions extends GestureOptions {\n  maxDuration: number;\n  maxDistance: number;\n}\n\n/*\n * TAP DEFINITION\n * - user touches the screen with one finger or presses the mouse button down\n * - the finger does not move for x ms\n * - no additional fingers are added\n * - the finger is released, Tap is no recognized\n */\nexport class Tap extends SinglePointerGesture {\n\n  constructor(domElement: HTMLElement, options?: Partial<TapOptions>) {\n    super(domElement, options);\n\n    this.validPointerManagerState = PointerManagerState.NoPointer;\n\n    this.eventBaseName = \"tap\";\n\n    let globalMaxDuration = 200;\n    let liveMaxDistance = 30;\n    let globalMaxDistance = 30;\n\n    if (options){\n      if (\"maxDuration\" in options){\n        globalMaxDuration = options[\"maxDuration\"];\n      }\n\n      if (\"maxDistance\" in options){\n        liveMaxDistance = options[\"maxDistance\"];\n        globalMaxDistance = options[\"maxDistance\"];\n      }\n    }\n\n    this.initialParameters.global.max[\"duration\"] = globalMaxDuration; // milliseconds. after a certain touch duration, it is not a TAP anymore\n\n    this.initialParameters.live.max[\"distance\"] = liveMaxDistance; // if a certain distance is detected, TAP becomes impossible\n    this.initialParameters.global.max[\"distance\"] = globalMaxDistance; // if a certain distance is detected, TAP becomes impossible\n\n  }\n\n  validate(pointerManager: PointerManager): boolean {\n\n    let isValid = this.validateGestureState();\n\n    if (isValid == true){\n      isValid = this.validatePointerManagerState(pointerManager);\n    }\n\n    if (isValid === true) {\n\n      if (pointerManager.lastInputSessionPointerCount != 1) {\n        return false;\n      }\n      else {\n\n        const singlePointerInput = pointerManager.getlastRemovedPointerInput();\n\n        if (singlePointerInput instanceof SinglePointerInput) {\n\n          isValid = this.validateGestureParameters(singlePointerInput);\n\n        }\n        else {\n          isValid = false;\n        }\n      }\n\n    }\n\n    return isValid;\n  }\n\n  // do not set Tap.state = GestureState.active as Tap has no active state\n  onStart(pointerManager: PointerManager): void {\n    this.setInitialPointerEvent(pointerManager);\n    this.emit(pointerManager);\n  }\n\n}","import { GestureOptions } from \"./Gesture\";\nimport { SinglePointerGesture } from \"./SinglePointerGesture\";\nimport { PointerManager } from \"../PointerManager\";\nimport { SinglePointerInput } from \"../SinglePointerInput\";\nimport { GestureState } from \"../input-consts\";\n\n\ninterface PressOptions extends GestureOptions {\n  minDuration: number,\n  maxDistance: number,\n}\n/*\n * press should only be fired once\n * if global duration is below Press.initialMinMaxParameters[\"duration\"][0], set the Press to possible\n * if global duration is above Press.initialMinMaxParameters[\"duration\"][0] AND press already has been emitted, set Press to impossible\n *\n */\nexport class Press extends SinglePointerGesture {\n  hasBeenEmitted: boolean;\n\n  private static minDuration = 600;\n\n  constructor(domElement: HTMLElement, options?: Partial<PressOptions>) {\n    super(domElement, options);\n\n    this.eventBaseName = \"press\";\n\n    let globalMinDuration = 600;\n    let globalMaxDistance = 10;\n    let globalMaxMaximumDistance = 20;\n\n    if (options){\n      if (\"minDuration\" in options){\n        globalMinDuration = options[\"minDuration\"];\n      }\n\n      if (\"maxDistance\" in options){\n        globalMaxMaximumDistance = options[\"maxDistance\"];\n        globalMaxDistance = options[\"maxDistance\"];\n      }\n    }\n\n    this.initialParameters.global.min[\"duration\"] = globalMinDuration; // milliseconds. after a certain touch duration, it is not a TAP anymore\n\n    this.initialParameters.global.max[\"distance\"] = globalMaxDistance; // if the pointer moved a certain distance, Press becomes impossible\n    this.initialParameters.global.max[\"maximumDistance\"] = globalMaxMaximumDistance;\n    // only Press has this parameter\n    this.hasBeenEmitted = false;\n\n  }\n\n  recognize(pointerManager: PointerManager): void {\n    const isValid = this.validate(pointerManager);\n\n    const singlePointerInput = this.getPointerInput(pointerManager);\n\n    // is this line really necessary? ESLint complains if it is not present, although its value is set in the constructor\n    // adding Object.freeze(this.initialParameters) in the constructor did not resolve the ESLint error\n    const minDuration = this.initialParameters.global.min[\"duration\"] || Press.minDuration;\n\n    if (singlePointerInput instanceof SinglePointerInput) {\n\n      if (\n        isValid == true &&\n        this.hasBeenEmitted == false\n      ) {\n\n        this.setInitialPointerEvent(pointerManager);\n\n        this.emit(pointerManager);\n\n        this.hasBeenEmitted = true;\n        this.state = GestureState.Active;\n        this.blockGestures();\n\n      } else if (isValid == false && this.hasBeenEmitted == true) {\n        this.onEnd(pointerManager);\n        this.state = GestureState.Inactive;\n        this.hasBeenEmitted = false;\n      } else {\n        const duration = singlePointerInput.parameters.global.duration;\n\n        if (\n          this.hasBeenEmitted == true &&\n          duration <= minDuration\n        ) {\n          this.hasBeenEmitted = false;\n        }\n      }\n    }\n\n    if (singlePointerInput == null) {\n      this.hasBeenEmitted = false;\n    }\n  }\n}","import { GestureOptions } from \"./Gesture\";\nimport { SinglePointerGesture } from \"./SinglePointerGesture\";\nimport { PointerManager } from \"../PointerManager\";\nimport { SinglePointerInput } from \"../SinglePointerInput\";\n\nimport {\n  Directions,\n  PointerManagerState,\n  GestureState,\n} from \"../input-consts\";\nimport { Direction } from \"..\";\n\n/*\n * PAN DEFINITION:\n *\t- user touches surface with only one finger, or presses the mouse down\n *\t- user moves this one finger into different directions while staying on the surface, this movement is required\n *\t- the start of a pan is defined by a minimum pointerdown/touch duration and a minimum distance\n *\t- pan ends when the user removes the finger from the surface\n *\t- to detect a \"swipe\", the final speed is used\n *\t- a SWIPE is a pan that ended with a high speed (velocity without direction)\n *\t- Pan supports directions. options[\"supportedDirections\"] = []\n */\n\nexport class Pan extends SinglePointerGesture {\n  swipeFinalSpeed: number;\n  isSwipe: boolean;\n  initialSupportedDirections: string[];\n\n  constructor(domElement: HTMLElement, options?: Partial<GestureOptions>) {\n    super(domElement, options);\n\n    this.validPointerManagerState = PointerManagerState.SinglePointer;\n\n    this.eventBaseName = \"pan\";\n\n    this.initialParameters.global.min[\"duration\"] = 0;\n    this.initialParameters.live.min[\"distance\"] = 10;\n    this.initialParameters.global.boolean[\"hasBeenMoved\"] = true;\n\n    this.swipeFinalSpeed = 600;\n\n    this.isSwipe = false;\n\n    this.options.supportedDirections = options?.supportedDirections ?? Directions.All;\n    this.initialSupportedDirections = this.options.supportedDirections;\n  }\n\n  validate(pointerManager: PointerManager): boolean {\n    // on second recognition allow all directions. otherwise, the \"pan\" mode would end if the finger was moved right and then down during \"panleft\" mode\n    if (this.state == GestureState.Active) {\n      this.options.supportedDirections = Directions.All;\n    }\n\n    const isValid = super.validate(pointerManager);\n\n    return isValid;\n  }\n\n  onStart(pointerManager: PointerManager): void {\n    this.isSwipe = false;\n\n    super.onStart(pointerManager);\n  }\n\n  // check if it was a swipe\n  onEnd(pointerManager: PointerManager): void {\n\n    const singlePointerInput = pointerManager.getlastRemovedPointerInput();\n\n    if (singlePointerInput instanceof SinglePointerInput) {\n\n      if (\n        this.swipeFinalSpeed < singlePointerInput.parameters.global.finalSpeed && singlePointerInput.parameters.live.vector.direction != Direction.None\n      ) {\n\n        this.isSwipe = true;\n        this.emit(pointerManager, \"swipe\");\n      }\n      else {\n        if (this.DEBUG == true){\n          if (singlePointerInput.parameters.global.finalSpeed < this.swipeFinalSpeed){\n            console.log(`[Pan] dismissing swipe. Final speed: ${singlePointerInput.parameters.global.finalSpeed} < ${this.swipeFinalSpeed}`);\n          }\n          else {\n            console.log(`[Pan] dismissing swipe. Direction: ${singlePointerInput.parameters.live.vector.direction}`);\n          }\n        }\n      }\n    }\n\n    super.onEnd(pointerManager);\n\n    this.options.supportedDirections = this.initialSupportedDirections;\n  }\n\n  onTouchMove(event: TouchEvent): void {\n    if (this.state == GestureState.Active) {\n      if (this.DEBUG == true) {\n        console.log(\"[Pan] preventing touchmove default\");\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n}\n","import { Geometry } from \"./geometry/Geometry\";\nimport {\n  Pointer,\n} from \"./Pointer\";\nimport {\n  DualPointerInputGlobalParameters,\n  DualPointerInputLiveParameters,\n  DualPointerInputParameters,\n} from \"./interfaces\";\n\n/**\n * DualPointerInput\n * \t- For gestures like Pinch, Rotate, TwoFingerPan\n */\nexport class DualPointerInput {\n\n  readonly pointerIds: Set<number>;\n\n  readonly pointerMap: Record<number, Pointer>;\n\n  readonly pointer_1: Pointer;\n  readonly pointer_2: Pointer;\n\n  readonly parameters: DualPointerInputParameters;\n\n  readonly initialPointerEvent: PointerEvent;\n  currentPointerEvent: PointerEvent;\n\n  readonly startTimestamp: number;\n\n  constructor(pointer_1: Pointer, pointer_2: Pointer) {\n\n    this.pointerIds = new Set([pointer_1.pointerId, pointer_2.pointerId]);\n\n    this.startTimestamp = new Date().getTime();\n\n    this.pointerMap = {};\n    this.pointerMap[pointer_1.pointerId] = pointer_1;\n    this.pointerMap[pointer_2.pointerId] = pointer_2;\n\n    this.pointer_1 = pointer_1;\n    this.pointer_2 = pointer_2;\n\n    this.initialPointerEvent = pointer_1.initialPointerEvent;\n    this.currentPointerEvent = pointer_1.initialPointerEvent;\n\n    const globalVector_1 = this.pointer_1.parameters.global.vector;\n    const globalVector_2 = this.pointer_2.parameters.global.vector;\n    const globalCenter = Geometry.getCenter(globalVector_1.startPoint, globalVector_2.startPoint);\n    const globalCenterMovementVector = Geometry.getCenterMovementVector(globalVector_1, globalVector_2);\n\n    const globalParameters: DualPointerInputGlobalParameters = {\n      duration: 0,\n      center: globalCenter,\n      centerHasBeenMoved: false,\n      centerMovementDistance: 0,\n      centerMovementVector: globalCenterMovementVector,\n      absolutePointerDistanceChange: 0,\n      relativePointerDistanceChange: 0,\n      rotationAngle: 0,\n      absoluteRotationAngle: 0,\n      vectorAngle: 0,\n      absoluteVectorAngle: 0,\n    };\n\n    const liveVector_1 = this.pointer_1.parameters.live.vector;\n    const liveVector_2 = this.pointer_2.parameters.live.vector;\n    const liveCenter = Geometry.getCenter(liveVector_1.startPoint, liveVector_2.startPoint);\n    const liveCenterMovementVector = Geometry.getCenterMovementVector(liveVector_1, liveVector_2);\n\n\n    const liveParameters: DualPointerInputLiveParameters = {\n      center: liveCenter,\n      centerIsMoving: false,\n      centerMovementDistance: 0,\n      centerMovementVector: liveCenterMovementVector,\n      absolutePointerDistanceChange: 0,\n      relativePointerDistanceChange: 0,\n      rotationAngle: 0,\n      absoluteRotationAngle: 0,\n      vectorAngle: 0,\n      absoluteVectorAngle: 0,\n    };\n\n    const parameters: DualPointerInputParameters = {\n      global: globalParameters,\n      live: liveParameters,\n    };\n\n    this.parameters = parameters;\n  }\n\n  removePointer(pointerId: number): Pointer {\n    if (pointerId == this.pointer_1.pointerId) {\n      return this.pointer_2;\n    }\n    else if (pointerId == this.pointer_2.pointerId) {\n      return this.pointer_1;\n    }\n    else {\n      throw new Error(`[DualPointerInput] cannot remove Pointer #${pointerId}. The pointer is not part of this DualPointerInput`);\n    }\n  }\n\n  getTarget(): EventTarget | null {\n    return this.initialPointerEvent.target;\n  }\n\n  update (pointerEvent?: PointerEvent): void {\n\n    if (pointerEvent instanceof PointerEvent){\n      this.currentPointerEvent = pointerEvent;\n    }\n\n    const now = new Date().getTime();\n    this.parameters.global[\"duration\"] = now - this.startTimestamp;\n\n    const globalVector_1 = this.pointer_1.parameters.global.vector;\n    const globalVector_2 = this.pointer_2.parameters.global.vector;\n    const globalCenter = Geometry.getCenter(globalVector_1.startPoint, globalVector_2.startPoint);\n    const globalCenterMovementVector = Geometry.getCenterMovementVector(globalVector_1, globalVector_2);\n    const globalAbsoluteDistanceChange = Geometry.calculateAbsoluteDistanceChange(globalVector_1, globalVector_2);\n    const globalRelativeDistanceChange = Geometry.calculateRelativeDistanceChange(globalVector_1, globalVector_2);\n    const globalRotationAngle = Geometry.calculateRotationAngle(globalVector_1, globalVector_2);\n    const globalVectorAngle = Geometry.calculateVectorAngle(globalVector_1, globalVector_2);\n\n    this.parameters.global[\"center\"] = globalCenter;\n    this.parameters.global[\"centerMovementVector\"] = globalCenterMovementVector;\n    this.parameters.global[\"centerMovementDistance\"] = globalCenterMovementVector.vectorLength;\n    this.parameters.global[\"absolutePointerDistanceChange\"] = globalAbsoluteDistanceChange;\n    this.parameters.global[\"relativePointerDistanceChange\"] = globalRelativeDistanceChange;\n    this.parameters.global[\"rotationAngle\"] = globalRotationAngle;\n    this.parameters.global[\"absoluteRotationAngle\"] = Math.abs(globalRotationAngle);\n    this.parameters.global[\"vectorAngle\"] = globalVectorAngle;\n    this.parameters.global[\"absoluteVectorAngle\"] = Math.abs(globalVectorAngle);\n\n    const liveVector_1 = this.pointer_1.parameters.live.vector;\n    const liveVector_2 = this.pointer_2.parameters.live.vector;\n    const liveCenter = Geometry.getCenter(liveVector_1.startPoint, liveVector_2.startPoint);\n    const liveCenterMovementVector = Geometry.getCenterMovementVector(liveVector_1, liveVector_2);\n    const liveAbsoluteDistanceChange = Geometry.calculateAbsoluteDistanceChange(liveVector_1, liveVector_2);\n    const liveRelativeDistanceChange = Geometry.calculateRelativeDistanceChange(liveVector_1, liveVector_2);\n    // calculate rotation angle. imagine the user turning a wheel with 2 fingers\n    const liveRotationAngle = Geometry.calculateRotationAngle(liveVector_1, liveVector_2);\n    const liveVectorAngle = Geometry.calculateVectorAngle(liveVector_1, liveVector_2);\n\n    if (liveCenterMovementVector.vectorLength > 0){\n      this.parameters.live.centerIsMoving = true;\n      this.parameters.global.centerHasBeenMoved = true;\n    }\n    else {\n      this.parameters.live.centerIsMoving = false;\n    }\n\n    this.parameters.live[\"center\"] = liveCenter;\n    this.parameters.live[\"centerMovementDistance\"] = liveCenterMovementVector.vectorLength;\n    this.parameters.live[\"centerMovementVector\"] = liveCenterMovementVector;\n    this.parameters.live[\"absolutePointerDistanceChange\"] = liveAbsoluteDistanceChange;\n    this.parameters.live[\"relativePointerDistanceChange\"] = liveRelativeDistanceChange;\n    this.parameters.live[\"rotationAngle\"] = liveRotationAngle;\n    this.parameters.live[\"absoluteRotationAngle\"] = Math.abs(liveRotationAngle);\n    this.parameters.live[\"vectorAngle\"] = liveVectorAngle;\n    this.parameters.live[\"absoluteVectorAngle\"] = Math.abs(liveVectorAngle);\n  }\n\n  onPointerMove(pointermoveEvent: PointerEvent): void {\n    this.update(pointermoveEvent);\n  }\n\n  onPointerUp(pointerupEvent: PointerEvent): void {\n    this.update(pointerupEvent);\n  }\n\n  onPointerLeave(pointerleaveEvent: PointerEvent): void {\n    this.update(pointerleaveEvent);\n  }\n\n  onPointerCancel(pointercancelEvent: PointerEvent): void {\n    this.update(pointercancelEvent);\n  }\n\n  onIdle(): void {\n    this.update();\n  }\n\n  // string is not good, it should be Direction\n  getCurrentDirection() : string {\n    return this.parameters.live.centerMovementVector.direction;\n  }\n\n  getCurrentPointerEvent(): PointerEvent {\n    return this.currentPointerEvent;\n  }\n\n}\n","import {\n  Gesture,\n  GestureOptions,\n  LiveGestureEventData,\n  GlobalGestureEventData,\n  GestureEventData,\n} from \"./Gesture\";\n\nimport {\n  DualPointerGestureParameters,\n} from \"../interfaces\";\n\nimport { DualPointerInput } from \"../DualPointerInput\";\n\nimport {\n  PointerManagerState\n} from \"../input-consts\";\n\nexport abstract class DualPointerGesture extends Gesture {\n\n  initialPointerEvent_1: PointerEvent | null;\n  initialPointerEvent_2: PointerEvent | null;\n\n  initialParameters: DualPointerGestureParameters;\n  activeStateParameters: DualPointerGestureParameters;\n\n  constructor(domElement: HTMLElement, options?: Partial<GestureOptions>) {\n    super(domElement, options);\n    this.initialPointerEvent_1 = null;\n    this.initialPointerEvent_2 = null;\n    this.validPointerManagerState = PointerManagerState.DualPointer;\n    this.validPointerInputConstructor = DualPointerInput;\n\n    const nullRecognitionParameters = this.getEmptyGestureParameters() as DualPointerGestureParameters;\n\n    this.initialParameters = { ...nullRecognitionParameters };\n    this.activeStateParameters = JSON.parse(JSON.stringify({ ...nullRecognitionParameters }));\n  }\n\n  getEventData(dualPointerInput: DualPointerInput): GestureEventData {\n    // provide short-cuts to the values collected in the Contact object\n    // match this to the event used by hammer.js\n\n    const globalParameters = dualPointerInput.parameters.global;\n    const liveParameters = dualPointerInput.parameters.live;\n\n    const globalGestureEventData: GlobalGestureEventData = {\n      deltaX: globalParameters.centerMovementVector.x,\n      deltaY: globalParameters.centerMovementVector.y,\n      distance: globalParameters.centerMovementDistance,\n      speedX: globalParameters.centerMovementVector.x / globalParameters.duration,\n      speedY: globalParameters.centerMovementVector.y / globalParameters.duration,\n      speed:\n        globalParameters.centerMovementVector.vectorLength / globalParameters.duration,\n      direction: globalParameters.centerMovementVector.direction,\n      scale: globalParameters.relativePointerDistanceChange,\n      rotation: globalParameters.rotationAngle,\n      srcEvent: dualPointerInput.currentPointerEvent,\n    };\n\n    const liveGestureEventData: LiveGestureEventData = {\n      deltaX: liveParameters.centerMovementVector.x,\n      deltaY: liveParameters.centerMovementVector.y,\n      distance: liveParameters.centerMovementDistance,\n      speedX: liveParameters.centerMovementVector.x / globalParameters.duration,\n      speedY: liveParameters.centerMovementVector.y / globalParameters.duration,\n      speed: liveParameters.centerMovementVector.vectorLength / globalParameters.duration,\n      direction: liveParameters.centerMovementVector.direction,\n      scale: liveParameters.relativePointerDistanceChange,\n      rotation: liveParameters.rotationAngle,\n      center: {\n        x: liveParameters.centerMovementVector.startPoint.x,\n        y: liveParameters.centerMovementVector.startPoint.y,\n      },\n      srcEvent: dualPointerInput.currentPointerEvent,\n    };\n\n    const gestureEventData: GestureEventData = {\n      recognizer: this,\n      global: globalGestureEventData,\n      live: liveGestureEventData\n    };\n\n    return gestureEventData;\n  }\n\n}","import { DualPointerGesture } from \"./DualPointerGesture\";\nimport { GestureOptions } from \"./Gesture\";\n\n/*\n * PINCH DEFINITION\n * - 2 fingers touch the surface\n * - those fongers are moved towards each other, or away from each other\n * - 2 fingers define a circle: center=middle between two touches, diameter = distance\n * - the center between the 2 fingers stays at the same coordinates\n * - the distance between the 2 start points and the two end points is reduces (diameter shrinks)\n */\nexport class Pinch extends DualPointerGesture {\n  constructor(domElement: HTMLElement, options?: Partial<GestureOptions>) {\n    super(domElement, options);\n\n    this.eventBaseName = \"pinch\";\n\n    this.initialParameters.live.min[\"centerMovementDistance\"] = 0;\n    this.initialParameters.live.max[\"centerMovementDistance\"] = 50; //px\n    this.initialParameters.live.min[\"absolutePointerDistanceChange\"] = 5; // distance between 2 fingers\n    this.initialParameters.live.max[\"absoluteRotationAngle\"] = 20;\n    this.initialParameters.live.min[\"absoluteVectorAngle\"] = 10;\n  }\n}","import { DualPointerGesture } from \"./DualPointerGesture\";\nimport { GestureOptions } from \"./Gesture\";\n\n/*\n * ROTATE DEFINITION\n * - 2 fingers touch the surface\n * - 1 or 2 fingers are moved in a circular motion. the center is between the 2 fingers\n */\n\nexport class Rotate extends DualPointerGesture {\n  constructor(domElement: HTMLElement, options?: Partial<GestureOptions>) {\n    super(domElement, options);\n\n    this.eventBaseName = \"rotate\";\n\n    this.initialParameters.live.min[\"centerMovementDistance\"] = 0;\n    this.initialParameters.live.max[\"centerMovementDistance\"] = 50;\n    this.initialParameters.live.max[\"absolutePointerDistanceChange\"] = 50;\n    this.initialParameters.live.min[\"absoluteRotationAngle\"] = 5;\n\n    this.activeStateParameters.live.min[\"absoluteRotationAngle\"] = 0;\n  }\n}","import { DualPointerGesture } from \"./DualPointerGesture\";\nimport { GestureOptions } from \"./Gesture\";\n\n/*\n * TWOFINGERPAN DEFINITION\n * 2 fingers are moved across the surface, in the same direction\n */\nexport class TwoFingerPan extends DualPointerGesture {\n  constructor(domElement: HTMLElement, options?: Partial<GestureOptions>) {\n    super(domElement, options);\n\n    this.eventBaseName = \"twofingerpan\";\n\n    this.initialParameters.live.min[\"centerMovementDistance\"] = 10;\n    this.initialParameters.live.max[\"absolutePointerDistanceChange\"] = 50;\n    this.initialParameters.live.max[\"absoluteVectorAngle\"] = 150;\n\n    this.activeStateParameters.live.min[\"centerMovementDistance\"] = 0;\n\n  }\n}\n","import { PointerManagerState } from \"./input-consts\";\nimport { Pointer } from \"./Pointer\";\nimport { SinglePointerInput } from \"./SinglePointerInput\";\nimport { DualPointerInput } from \"./DualPointerInput\";\n\n/*\n * At the time the user touches the surface it is not known which gesture he will perform. He can also add or remove touches.\n * The contact phenomenon starts when the user initially touches the surface, and ends when no more touches are present.\n * During the contact phenonmenon between human being and artificial surface, different gestures can be detected.\n * According to the gesture definitions, a gesture can be possible or impossible at a given time.\n */\n\n/*\n*\tPointerManager\n*\t- keeps track of added and removed pointers\n*\t- decides if the current gesture is SinglePointerInput or DualPointerInput\n*\t\tbecomes activeSinglePointerInput\n*/\ninterface PointerManagerOptions {\n  DEBUG: boolean,\n}\n\nexport class PointerManager {\n\n  DEBUG: boolean;\n\n  activePointerInput: SinglePointerInput | DualPointerInput | null;\n\n  // this pointer is not on the surface any more - some gestures are detected after a pointer has been released\n  lastRemovedPointer: Pointer | null;\n\n  lastInputSessionPointerCount: number;\n\n  private pointerAllocation: Record<number, SinglePointerInput | DualPointerInput>; // map pointerId to the *PointerInput the Pointer is currently used for\n  private unusedPointers: Record<number, Pointer>; // on the surface, but not used for gesture recognition, eg a third pointer\n  private onSurfacePointers: Record<number, Pointer>; // covers active and unused Pointers\n\n  state: PointerManagerState;\n\n  options: PointerManagerOptions;\n\n  constructor(options?: Partial<PointerManagerOptions>) {\n\n    options = options || {};\n\n    this.options = {\n      DEBUG: false,\n      ...options\n    };\n\n    this.DEBUG = this.options.DEBUG;\n\n    this.state = PointerManagerState.NoPointer;\n    this.activePointerInput = null;\n    this.lastRemovedPointer = null;\n    this.lastInputSessionPointerCount = 0;\n    this.pointerAllocation = {};\n    this.unusedPointers = {}; // pointers on the surface that are not interpreted right now\n    this.onSurfacePointers = {};\n\n  }\n\n  addPointer(pointerdownEvent: PointerEvent): void {\n\n    if (this.DEBUG == true) {\n      console.log(`[PointerManager] adding Pointer #${pointerdownEvent.pointerId.toString()}`);\n    }\n\n    const pointerOptions = {\n      DEBUG: this.DEBUG,\n    };\n    const pointer = new Pointer(pointerdownEvent, pointerOptions);\n\n    this.onSurfacePointers[pointer.pointerId] = pointer;\n\n    if (this.activePointerInput == null) {\n      this.setActiveSinglePointerInput(pointer);\n    }\n    else if (this.activePointerInput instanceof SinglePointerInput) {\n      this.setActiveDualPointerInput(this.activePointerInput.pointer, pointer);\n    }\n    else if (this.activePointerInput instanceof DualPointerInput) {\n      this.unusedPointers[pointer.pointerId] = pointer;\n    }\n\n    this.lastInputSessionPointerCount = this.currentPointerCount();\n\n  }\n\n  /**\n   * called on the following events: pointerup, pointerleave(?), pointercancel\n   * 1 -> 0 : SinglePointerInput -> null\n   * 2 -> 1 : DualPointerInput -> SinglePointerInput\n   * 3 -> 2 : DualPointerInput -> DualPointerInput (new combination or no change)\n   */\n  removePointer(pointerId: number): void {\n\n    if (this.DEBUG == true) {\n      console.log(`[PointerManager] starting to remove Pointer #${pointerId}`);\n      console.log(`[PointerManager] state: ${this.state}`);\n    }\n\n    const pointer: Pointer = this.onSurfacePointers[pointerId];\n    this.lastRemovedPointer = pointer;\n\n    // remove from registries\n    delete this.onSurfacePointers[pointerId];\n\n    if (pointerId in this.unusedPointers) {\n      delete this.unusedPointers[pointerId];\n    }\n\n    // set this.activePointerInput to null if the Pointer was part of it\n    // DualPointerInput -> SinglePointerInput\n    // OR DualPointerInput -> new DualPointerInput\n    if (this.activePointerInput instanceof DualPointerInput) {\n\n      if (this.activePointerInput.pointerIds.has(pointerId)) {\n        if (this.DEBUG == true) {\n          console.log(`[PointerManager] removing Pointer #${pointerId} from DualPointerInput`);\n        }\n        const remainingPointer = this.activePointerInput.removePointer(pointerId);\n        this.activePointerInput = null;\n\n        // remainingPointer should be used for the next this.activePointerInput\n        const unusedPointerInput = this.getUnusedPointer();\n        if (unusedPointerInput instanceof Pointer) {\n          this.setActiveDualPointerInput(remainingPointer, unusedPointerInput);\n        }\n        else {\n          this.setActiveSinglePointerInput(remainingPointer);\n        }\n\n      }\n      else {\n        // a 3rd pointer which has not been part of DualPointerInput has been removed\n      }\n    } else if (this.activePointerInput instanceof SinglePointerInput) {\n\n      if (this.DEBUG == true) {\n        console.log(`[PointerManager] removing Pointer #${pointerId} from SinglePointerInput`);\n      }\n\n      this.activePointerInput = null;\n      this.state = PointerManagerState.NoPointer;\n      // this should not be necessary\n      if (Object.keys(this.unusedPointers).length > 0) {\n        this.unusedPointers = {};\n        throw new Error(\"[PointerManager] found unused Pointers although there should not be any\");\n      }\n      if (Object.keys(this.onSurfacePointers).length > 0) {\n        this.onSurfacePointers = {};\n        throw new Error(\"[PointerManager] found onSurfacePointers although there should not be any\");\n      }\n\n    }\n\n    if (this.DEBUG == true) {\n      console.log(`[PointerManager] state: ${this.state}`);\n    }\n\n  }\n\n  setActiveSinglePointerInput(pointer: Pointer): void {\n    pointer.reset();\n    const singlePointerInput = new SinglePointerInput(pointer);\n    this.activePointerInput = singlePointerInput;\n\n    this.pointerAllocation[pointer.pointerId] = singlePointerInput;\n    delete this.unusedPointers[pointer.pointerId];\n\n    this.state = PointerManagerState.SinglePointer;\n\n    if (this.DEBUG == true) {\n      console.log(`[PointerManager] state: ${this.state}`);\n    }\n  }\n\n  setActiveDualPointerInput(pointer_1: Pointer, pointer_2: Pointer): void {\n    pointer_1.reset();\n    pointer_2.reset();\n    const dualPointerInput = new DualPointerInput(pointer_1, pointer_2);\n    this.activePointerInput = dualPointerInput;\n\n    this.pointerAllocation[pointer_1.pointerId] = dualPointerInput;\n    this.pointerAllocation[pointer_2.pointerId] = dualPointerInput;\n    delete this.unusedPointers[pointer_1.pointerId];\n    delete this.unusedPointers[pointer_2.pointerId];\n\n    this.state = PointerManagerState.DualPointer;\n\n    if (this.DEBUG == true) {\n      console.log(`[PointerManager] state: ${this.state}`);\n    }\n  }\n\n  hasPointersOnSurface(): boolean {\n    if (Object.keys(this.onSurfacePointers).length > 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  currentPointerCount(): number {\n    return Object.keys(this.onSurfacePointers).length;\n  }\n\n  getUnusedPointer(): Pointer | null {\n    if (Object.keys(this.unusedPointers).length > 0) {\n      const pointer: Pointer = Object.values(this.unusedPointers)[0];\n      return pointer;\n    }\n    return null;\n  }\n\n  getPointerFromId(pointerId: number): Pointer | null {\n    if (pointerId in this.onSurfacePointers) {\n      return this.onSurfacePointers[pointerId];\n    }\n    return null;\n  }\n\n  getlastRemovedPointerInput(): SinglePointerInput | DualPointerInput | null {\n    if (this.lastRemovedPointer instanceof Pointer) {\n      return this.pointerAllocation[this.lastRemovedPointer.pointerId];\n    }\n    return null;\n  }\n\n  onIdle(): void {\n    for (const pointerId in this.onSurfacePointers) {\n      const pointer: Pointer = this.onSurfacePointers[pointerId];\n      pointer.onIdle();\n    }\n\n    this.activePointerInput?.onIdle();\n\n  }\n\n  /**\n   * PointerEvent handlers\n   * - the Pointer is always updated firs\n   * - afterwards, the current activePointerInput is updated\n   */\n  onPointerMove(pointermoveEvent: PointerEvent): void {\n    const pointer = this.getPointerFromId(pointermoveEvent.pointerId);\n    if (pointer instanceof Pointer) {\n      pointer.onPointerMove(pointermoveEvent);\n    }\n    this.activePointerInput?.onPointerMove(pointermoveEvent);\n  }\n\n  onPointerUp(pointerupEvent: PointerEvent): void {\n    if (this.DEBUG == true) {\n      console.log(\"[PointerManager] pointerup detected\");\n    }\n    const pointer = this.getPointerFromId(pointerupEvent.pointerId);\n    if (pointer instanceof Pointer) {\n      pointer.onPointerUp(pointerupEvent);\n    }\n    this.activePointerInput?.onPointerUp(pointerupEvent);\n    this.removePointer(pointerupEvent.pointerId);\n  }\n\n  /*onPointerOver(pointeroverEvent: PointerEvent): void {\n\n  }\n\n  onPointerLeave(pointerleaveEvent: PointerEvent): void {\n    if (this.DEBUG == true) {\n      console.log(`[PointerManager] pointerLeave detected`);\n    }\n    const pointer = this.getPointerFromId(pointerleaveEvent.pointerId);\n    if (pointer instanceof Pointer) {\n      pointer.onPointerLeave(pointerleaveEvent);\n    }\n    this.activePointerInput?.onPointerLeave(pointerleaveEvent);\n    // pointerleave does not mean th pointer left the surface\n    // the pointer left the bound element\n    this.removePointer(pointerleaveEvent.pointerId);\n  }\n\n  onPointerOut(pointeroutEvent: PointerEvent): void {\n    if (this.DEBUG == true) {\n      console.log(`[PointerManager] pointerout detected`);\n    }\n    const pointer = this.getPointerFromId(pointeroutEvent.pointerId);\n    if (pointer instanceof Pointer) {\n      pointer.onPointerLeave(pointeroutEvent);\n    }\n    this.activePointerInput?.onPointerLeave(pointeroutEvent);\n    // pointerleave does not mean th pointer left the surface\n    // the pointer left the bound element\n    this.removePointer(pointeroutEvent.pointerId);\n  }*/\n\n  onPointerCancel(pointercancelEvent: PointerEvent): void {\n    if (this.DEBUG == true) {\n      console.log(\"[PointerManager] pointercancel detected\");\n    }\n    const pointer = this.getPointerFromId(pointercancelEvent.pointerId);\n    if (pointer instanceof Pointer) {\n      pointer.onPointerCancel(pointercancelEvent);\n    }\n    this.activePointerInput?.onPointerCancel(pointercancelEvent);\n    this.removePointer(pointercancelEvent.pointerId);\n  }\n\n}","import { Gesture } from \"./gestures/Gesture\";\nimport { Tap } from \"./gestures/Tap\";\nimport { Press } from \"./gestures/Press\";\nimport { Pan } from \"./gestures/Pan\";\nimport { Pinch } from \"./gestures/Pinch\";\nimport { Rotate } from \"./gestures/Rotate\";\nimport { TwoFingerPan } from \"./gestures/TwoFingerPan\";\nimport { PointerManager } from \"./PointerManager\";\nimport {\n  PointerListenerState,\n  GestureState,\n} from \"./input-consts\";\n\n/*\n * PointerListener class\n *\t- implements the possibility to listen to gesture events performed on a specific DOM Element\n *\t  expample: element.addEventListener(\"pan\", function(event){});\n *\t- creates the PointerManager instance\n *\t- updates the PointerManager instance\n *\t- uses the PointerManager instance to determine which gesture(s) are performed by passing PointerManager instances to GestureRegonizers\n *\n *\t- var listener = new PointerListener(domElement, {});\n *\t- domElement.addEventListener(\"pan\", function(){});\n */\n\n/**\n * pointerdownEvent ->  PointerListener.onPointerDown -> PointerManager.addPointer -> recognizeGestures (on move, idle, up, leave, cancel)\n * pointerupEvent -> PointerListener.onPointerUp -> PointerManager.onPointerUp -> Pointeristener.recognizeGestures\n */\n\ntype GestureConstructor = new (...args: ConstructorParameters<typeof Gesture>) => Gesture;\n\nconst ALL_GESTURE_CLASSES: GestureConstructor[] = [Tap, Press, Pan, Pinch, Rotate, TwoFingerPan];\n\ntype Timer = ReturnType<typeof setInterval>;\n\ninterface PointerListenerOptions {\n  DEBUG: boolean;\n  DEBUG_GESTURES: boolean;\n  DEBUG_POINTERMANAGER: boolean;\n\n  bubbles: boolean;\n  handleTouchEvents: boolean;\n  consecutiveGestures: boolean,\n  simultaneousGestures: boolean,\n  supportedGestures: (Gesture | GestureConstructor)[];\n\n  // Hooks\n  pointerdown?: (event: PointerEvent, self: PointerListener) => void;\n  pointermove?: (event: PointerEvent, self: PointerListener) => void;\n  pointerup?: (event: PointerEvent, self: PointerListener) => void;\n  pointercancel?: (event: PointerEvent, self: PointerListener) => void;\n}\n\n\nexport class PointerListener {\n  readonly options: PointerListenerOptions;\n  DEBUG: boolean;\n\n  private readonly domElement: HTMLElement;\n\n  private readonly gestureEventHandlers: Record<string, EventListenerOrEventListenerObject[]>;\n  private pointerEventHandlers: Record<string, (event: PointerEvent) => void>;\n  private touchEventHandlers: Record<string, (event: TouchEvent) => void>;\n\n  private pointerManager: PointerManager;\n\n  private lastRecognitionTimestamp: number | null;\n  private idleRecognitionIntervalId: Timer | null;\n\n  private supportedGestures: Gesture[];\n\n  state: PointerListenerState;\n\n  activeGestures: Gesture[];\n  private hadActiveGestureDuringCurrentContact: boolean;\n\n  constructor(domElement: HTMLElement, options?: Partial<PointerListenerOptions>) {\n\n    this.state = PointerListenerState.NoActiveGesture;\n    this.activeGestures = [];\n\n    this.hadActiveGestureDuringCurrentContact = false;\n\n    // registry for events like \"pan\", \"rotate\", which have to be removed on this.destroy();\n    this.gestureEventHandlers = {};\n\n    this.lastRecognitionTimestamp = null;\n    this.idleRecognitionIntervalId = null;\n\n    this.pointerEventHandlers = {};\n    this.touchEventHandlers = {};\n\n    options = options || {};\n\n    this.options = {\n      DEBUG: false,\n      DEBUG_GESTURES: false,\n      DEBUG_POINTERMANAGER: false,\n      bubbles: true,\n      handleTouchEvents: true,\n      consecutiveGestures: true,\n      simultaneousGestures: true,\n      supportedGestures: [],\n      ...options\n    };\n\n    this.DEBUG = this.options.DEBUG;\n\n    const supportedGestures = options.supportedGestures ?? ALL_GESTURE_CLASSES;\n\n    // instantiate gesture classes on domElement and add them to this.options\n    const instantiatedGestures = supportedGestures.map(GestureClass => {\n      if (typeof GestureClass === \"function\") {\n        const gestureOptions = {\n          bubbles: this.options.bubbles,\n          DEBUG: this.options.DEBUG_GESTURES,\n        };\n\n        return new GestureClass(domElement, gestureOptions);\n      }\n\n      if (typeof GestureClass === \"object\") {\n        return GestureClass;\n      }\n\n      throw new Error(`unsupported gesture type: ${typeof GestureClass}`);\n    });\n\n    // this.supportedGestures have to be instantiated gestures\n    this.supportedGestures = instantiatedGestures;\n\n    this.domElement = domElement;\n\n    const pointerManagerOptions = {\n      DEBUG: this.options.DEBUG_POINTERMANAGER,\n    };\n    this.pointerManager = new PointerManager(pointerManagerOptions);\n\n    // disable context menu on long taps - this kills pointermove\n    /*domElement.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n      return false;\n    });*/\n\n    this.addPointerEventListeners();\n\n    this.addTouchEventListeners();\n\n  }\n\n  /* PointerEvent handling */\n  private addPointerEventListeners(): void {\n\n    const domElement = this.domElement;\n\n    // create references, so the listener can be removed at a later time\n    // .bind(this): make sure that the instance of PointerListener is accessible in the EventHandler\n    const onPointerDown = this.onPointerDown.bind(this);\n    const onPointerMove = this.onPointerMove.bind(this);\n    const onPointerUp = this.onPointerUp.bind(this);\n    //const onPointerLeave = this.onPointerLeave.bind(this);\n    //const onPointerOut = this.onPointerOut.bind(this);\n    const onPointerCancel = this.onPointerCancel.bind(this);\n\n    domElement.addEventListener(\"pointerdown\", onPointerDown, { passive: true });\n    domElement.addEventListener(\"pointermove\", onPointerMove, { passive: true });\n    domElement.addEventListener(\"pointerup\", onPointerUp, { passive: true });\n    /*\n     * case: user presses mouse button and moves element. while moving, the cursor leaves the element (fires pointerout)\n     *\t\twhile outside the element, the mouse button is released. pointerup is not fired.\n     *\t\tduring pan, pan should not end if the pointer leaves the element.\n     * MDN: Pointer capture allows events for a particular pointer event (PointerEvent) to be re-targeted to a particular element instead of the normal (or hit test) target at a pointer's location. This can be used to ensure that an element continues to receive pointer events even if the pointer device's contact moves off the element (such as by scrolling or panning).\n     *  this problem is solved by using setPointerCapture()\n     */\n    //domElement.addEventListener(\"pointerleave\", onPointerLeave, { passive: true });\n    //domElement.addEventListener(\"pointerout\", onPointerOut, { passive: true });\n    domElement.addEventListener(\"pointercancel\", onPointerCancel, { passive: true });\n\n    this.pointerEventHandlers = {\n      pointerdown: onPointerDown,\n      pointermove: onPointerMove,\n      pointerup: onPointerUp,\n      //pointerleave: onPointerLeave,\n      //pointerout: onPointerOut,\n      pointercancel: onPointerCancel,\n    };\n\n  }\n\n  // there may be more than one pointer. Each new pointer fires onPointerDown\n  private onPointerDown(pointerdownEvent: PointerEvent) {\n    if (this.DEBUG == true) {\n      console.log(\"[PointerListener] pointerdown event detected\");\n    }\n\n    // re-target all pointerevents to the current element\n    // see https://developer.mozilla.org/en-US/docs/Web/API/Element/setPointerCapture\n    this.domElement.setPointerCapture(pointerdownEvent.pointerId);\n\n    this.pointerManager.addPointer(pointerdownEvent);\n\n    this.options.pointerdown?.(pointerdownEvent, this);\n\n    // before starting a new interval, make sure the old one is stopped if present\n    if (this.idleRecognitionIntervalId != null) {\n      this.clearIdleRecognitionInterval();\n    }\n\n    this.idleRecognitionIntervalId = setInterval(() => {\n      this.onIdle();\n    }, 100);\n  }\n\n  private onPointerMove(pointermoveEvent: PointerEvent) {\n    // pointermove is also firing if the mouse button is not pressed\n\n    if (this.pointerManager.hasPointersOnSurface() == true) {\n      // this would disable vertical scrolling - which should only be disabled if a panup/down or swipeup/down listener has been triggered\n      // event.preventDefault();\n\n      this.pointerManager.onPointerMove(pointermoveEvent);\n      this.recognizeGestures();\n\n      this.options.pointermove?.(pointermoveEvent, this);\n    }\n  }\n\n  private onPointerUp(pointerupEvent: PointerEvent) {\n    if (this.DEBUG == true) {\n      console.log(\"[PointerListener] pointerup event detected\");\n    }\n\n    this.domElement.releasePointerCapture(pointerupEvent.pointerId);\n\n    if (this.pointerManager.hasPointersOnSurface() == true) {\n\n      this.pointerManager.onPointerUp(pointerupEvent);\n      this.recognizeGestures();\n\n      this.options.pointerup?.(pointerupEvent, this);\n    }\n\n    this.clearIdleRecognitionInterval();\n  }\n\n  /*private onPointerLeave(event: PointerEvent) {\n    if (this.DEBUG == true) {\n      console.log(\"[PointerListener] pointerleave detected\");\n    }\n\n    if (this.pointerManager.hasPointersOnSurface() == true) {\n      this.pointerManager.onPointerLeave(event);\n      this.recognizeGestures();\n    }\n\n    this.clearIdleRecognitionInterval();\n  }\n\n  private onPointerOut(pointeroutEvent: PointerEvent) {\n    if (this.DEBUG == true) {\n      console.log(\"[PointerListener] pointerout detected\");\n    }\n\n    if (this.pointerManager.hasPointersOnSurface() == true) {\n      this.pointerManager.onPointerOut(pointeroutEvent);\n      this.recognizeGestures();\n    }\n\n    this.clearIdleRecognitionInterval();\n  }*/\n\n  private onPointerCancel(pointercancelEvent: PointerEvent) {\n    this.domElement.releasePointerCapture(pointercancelEvent.pointerId);\n\n    if (this.DEBUG == true) {\n      console.log(\"[PointerListener] pointercancel detected\");\n    }\n\n    this.pointerManager.onPointerCancel(pointercancelEvent);\n    this.recognizeGestures();\n\n    this.clearIdleRecognitionInterval();\n\n    this.options.pointercancel?.(pointercancelEvent, this);\n  }\n\n  public removePointerEventListeners(): void {\n    for (const event in this.pointerEventHandlers) {\n      const handler = this.pointerEventHandlers[event];\n      this.domElement.removeEventListener(event, handler as EventListener);\n    }\n  }\n\n  // provide the ability to interact/prevent touch events\n  // scrolling (touchmove event) results in pointerCancel event, stopping horizontal panning if user scrolls vertically\n  // the better solution is using eg css: touch-action: pan-y;\n  addTouchEventListeners(): void {\n    if (this.options.handleTouchEvents == true) {\n\n      const onTouchMove = this.onTouchMove.bind(this);\n\n      // do NOT make the touchmove listener passive, as this listener might block touch events from\n      // interfering with pan/swipe. Passive listeners make the promise not to block scrolling.\n      this.domElement.addEventListener(\"touchmove\", onTouchMove);\n\n      this.touchEventHandlers[\"touchmove\"] = onTouchMove;\n\n      /*this.domElement.addEventListener(\"touchstart\", (event) => {\n\n      }, { passive: true });*/\n\n      /*this.domElement.addEventListener(\"touchend\", (event) => {\n      }, { passive: true });\n\n      this.domElement.addEventListener(\"touchcancel\", (event) => {\n      }, { passive: true });*/\n    }\n  }\n\n  removeTouchEventListeners(): void {\n    for (const event in this.touchEventHandlers) {\n      const handler = this.touchEventHandlers[event];\n      this.domElement.removeEventListener(event, handler as EventListener);\n    }\n  }\n\n  private onTouchMove(event: TouchEvent): void {\n    // fire onTouchMove for all gestures\n    for (let g = 0; g < this.supportedGestures.length; g++) {\n      const gesture = this.supportedGestures[g];\n\n      gesture.onTouchMove(event);\n    }\n  }\n\n\n  // to recognize Press, recognition has to be run if the user does nothing while having contact with the surface (no pointermove, no pointerup, no pointercancel)\n  private onIdle(): void {\n    if (this.pointerManager.hasPointersOnSurface() == false) {\n      this.clearIdleRecognitionInterval();\n    } else {\n      const now = new Date().getTime();\n      let timedelta = null;\n\n      if (this.lastRecognitionTimestamp != null) {\n        timedelta = now - this.lastRecognitionTimestamp;\n      }\n\n      if (timedelta == null || timedelta > 100) {\n        this.pointerManager.onIdle();\n\n        if (this.DEBUG == true) {\n          console.log(\"[PointerListener] onIdle - running idle recognition\");\n        }\n\n        this.recognizeGestures();\n      }\n    }\n  }\n\n  private clearIdleRecognitionInterval(): void {\n    if (this.idleRecognitionIntervalId != null) {\n      clearInterval(this.idleRecognitionIntervalId);\n      this.idleRecognitionIntervalId = null;\n    }\n  }\n\n\n  /**\n   * respect the options \"consecutiveGestures\" and \"simultaneousGestures\"\n   */\n  private recognizeGestures(): void {\n\n    this.lastRecognitionTimestamp = new Date().getTime();\n\n    let gesturesForRecognition: Gesture[] = this.supportedGestures;\n\n    if ( this.options.simultaneousGestures == false && this.state == PointerListenerState.ActiveGesture){\n      gesturesForRecognition = [this.activeGestures[0]];\n    }\n    else if ( this.options.consecutiveGestures == false && this.state == PointerListenerState.ActiveGesture) {\n      gesturesForRecognition = [this.activeGestures[0]];\n    }\n    else if (this.options.consecutiveGestures == false && this.state == PointerListenerState.NoActiveGesture) {\n      if (this.hadActiveGestureDuringCurrentContact == true && this.pointerManager.hasPointersOnSurface() == true){\n        gesturesForRecognition = [];\n      }\n    }\n\n    for (let g = 0; g < gesturesForRecognition.length; g++) {\n      const gesture = gesturesForRecognition[g];\n\n      gesture.recognize(this.pointerManager);\n\n      this.updateActiveGestures(gesture);\n\n      if (this.options.simultaneousGestures == false && this.state == PointerListenerState.ActiveGesture){\n        break;\n      }\n    }\n\n    if (this.DEBUG == true){\n      console.log(\n        `[PointerListener] hadActiveGestureDuringCurrentContact: ${this.hadActiveGestureDuringCurrentContact}`\n      );\n    }\n\n    if (this.pointerManager.hasPointersOnSurface() == false){\n      this.hadActiveGestureDuringCurrentContact = false;\n    }\n\n  }\n\n  updateActiveGestures(gesture: Gesture): void {\n    if (gesture.state == GestureState.Active) {\n\n      this.hadActiveGestureDuringCurrentContact = true;\n\n      if (this.activeGestures.indexOf(gesture) < 0) {\n        this.activeGestures.push(gesture);\n      }\n    }\n    else {\n      // remove from active gestures\n      const index = this.activeGestures.indexOf(gesture);\n      if (index >= 0) {\n        this.activeGestures.splice(index, 1);\n      }\n    }\n\n    if (this.activeGestures.length > 0) {\n      this.state = PointerListenerState.ActiveGesture;\n    } else {\n      this.state = PointerListenerState.NoActiveGesture;\n    }\n\n  }\n\n  /*\n   *\thandler management\n   *\teventsString: one or more events: \"tap\" or \"pan twofingerpan pinchend\"\n   *\tcurrently, it is not supported to add the same handlerReference twice (once with useCapture = true, and once with useCapture = false)\n   *\tuseCapture defaults to false\n   */\n  private parseEventsString(eventsString: string): string[] {\n    return eventsString.trim().split(/\\s+/g);\n  }\n\n  on(eventsString: string, handlerReference: EventListenerOrEventListenerObject): void {\n    const eventTypes = this.parseEventsString(eventsString);\n\n    for (let e = 0; e < eventTypes.length; e++) {\n      const eventType = eventTypes[e];\n\n      if (!(eventType in this.gestureEventHandlers)) {\n        this.gestureEventHandlers[eventType] = [];\n      }\n\n      if (this.gestureEventHandlers[eventType].indexOf(handlerReference) == -1) {\n        this.gestureEventHandlers[eventType].push(handlerReference);\n      }\n\n      this.domElement.addEventListener(eventType, handlerReference, { capture: false, passive: true });\n    }\n  }\n\n  off(eventsString: string, handlerReference: EventListenerOrEventListenerObject): void {\n\n    const eventTypes = this.parseEventsString(eventsString);\n\n    if (this.DEBUG == true) {\n      console.log(\n        `[PointerListener] turning off events: ${eventsString}`\n      );\n      console.log(this.gestureEventHandlers);\n    }\n\n    for (let e = 0; e < eventTypes.length; e++) {\n      const eventType = eventTypes[e];\n\n      if (eventType in this.gestureEventHandlers) {\n\n        const handlerList = this.gestureEventHandlers[eventType];\n        const index = handlerList.indexOf(handlerReference);\n\n        if (this.DEBUG == true) {\n          console.log(\n            `[PointerListener] turning off ${eventType}. Index on handlerList: ${index}`\n          );\n        }\n\n        if (index >= 0) {\n          handlerList.splice(index, 1);\n\n          this.gestureEventHandlers[eventType] = handlerList;\n        }\n\n        this.domElement.removeEventListener(eventType, handlerReference, false);\n      }\n    }\n  }\n\n  destroy(): void {\n    // remove all EventListeners from this.domElement\n    for (const eventType in this.gestureEventHandlers) {\n      const handlerList = this.gestureEventHandlers[eventType];\n      for (let h = 0; h < handlerList.length; h++) {\n        const handler = handlerList[h];\n        this.domElement.removeEventListener(eventType, handler);\n      }\n\n      delete this.gestureEventHandlers[eventType];\n    }\n\n    this.removePointerEventListeners();\n    this.removeTouchEventListeners();\n  }\n\n}\n"],"names":["$a679181e97da1d47$export$cacd6541cfeeb6c1","Direction","$a679181e97da1d47$export$86ae6e8ac17a67c6","Object","freeze","Horizontal","Left","Right","Vertical","Up","Down","All","None","$a679181e97da1d47$export$a1d3109c03b1d511","GestureState","$a679181e97da1d47$export$b8339a9622c147c0","PointerManagerState","$a679181e97da1d47$export$2fb579dd5dfdbea","PointerListenerState","$371e257a8f59ebbd$export$baf26146a414f24a","constructor","x","y","this","$c0a0a4849382239c$export$9b781de7bf37bf48","startPoint","endPoint","direction","deltaX","deltaY","vectorLength","Math","sqrt","pow","abs","$9892efb410352ab9$export$2db6c17465f94a2","static","startPointerEvent","endPointerEvent","clientX","clientY","vector","startTimestamp","endTimestamp","speed","timespan_s","vector_1","vector_2","angleVector_1","angleVector_2","origin","translationVector_1","translatedEndPoint_1","translatePoint","translationVector_2","translatedEndPoint_2","rotationAngle","calcAngleRad","x_2_rotated","cos","sin","y_2_rotated","round","atan2","PI","angleDeg","angleRad","acos","rad2deg","point","newX","newY","angle","pointA","pointB","centerX","centerY","getCenter","vectorBetweenStartPoints","$e24396531d1264aa$export$bbcc47898202c6b8","pointer","parameters","getTarget","initialPointerEvent","target","getCurrentPointerEvent","currentPointerEvent","getCurrentDirection","live","onIdle","onPointerMove","pointermoveEvent","onPointerUp","pointerupEvent","onPointerLeave","pointerleaveEvent","onPointerCancel","pointercancelEvent","$e5661809384330e7$var$PointerState","PointerState","$e5661809384330e7$export$b56007f12edf0c17","pointerEvent","options","DEBUG","now","Date","getTime","pointerId","vectorTimespan","recognizedEvents","state","Active","nullVector","getVector","global","startX","startY","startTimestampUTC","timeStamp","currentTimestamp","maximumSpeed","currentSpeed","distance","maximumDistance","averageSpeed","finalSpeed","traveledDistance","hasBeenMoved","duration","isMoving","reset","update","Removed","console","log","Canceled","push","timedPointerEvents","getTimedPointerEvents","liveVector","getSpeed","globalVector","length","startIndex","elapsedTime","endTimeStamp","pointerEvents","slice","$2c17106273202fe9$export$6e9c3b1e1fa2b597","CustomEvent","$2c17106273202fe9$export$61ce360501d38a6f","domElement","Inactive","validPointerManagerState","validPointerInputConstructor","initialParameters","activeStateParameters","bubbles","blocks","supportedDirections","getEmptyGestureParameters","min","max","boolean","getGestureParameters","gestureParameters","eventBaseName","Error","validateGestureParameters","pointerInput","timespan","isValid","timedGestureParameters","timedPointerInputValues","minOrMaxOrBoolean","evaluationParameters","gestureParameterName","gestureParameter","pointerInputValue","startsWith","validateBooleanParameter","validateMinMaxParameter","minOrMax","validateDirection","currentDirection","includes","validateGestureState","Blocked","validatePointerManagerState","pointerManager","validatePointerInputConstructor","validate","activePointerInput","recognize","onStart","setInitialPointerEvent","emit","onEnd","getPointerInput","hasPointersOnSurface","lastRemovedPointer","getlastRemovedPointerInput","eventName","EventTarget","eventData","getEventData","eventOptions","detail","event","dispatchEvent","d","directionEventName","directionEvent","blockGestures","unblockGestures","onTouchStart","onTouchMove","onTouchEnd","onTouchCancel","block","gesture","indexOf","unblock","splice","g","$1601fa93fc399afe$export$718b85c80185d86e","super","SinglePointer","nullRecognitionParameters","JSON","parse","stringify","singlePointerInput","globalParameters","liveParameters","globalDuration","globalStartPoint","globalEndPoint","recognizer","speedX","speedY","scale","rotation","srcEvent","center","$6dba6490e7c85df8$export$4451a18ddc7083b7","NoPointer","globalMaxDuration","liveMaxDistance","globalMaxDistance","lastInputSessionPointerCount","$f829e854c7d609ac$export$90610caf6d8d0242","globalMinDuration","globalMaxMaximumDistance","hasBeenEmitted","minDuration","$5a17d735ab76ec40$export$f86166cd6057c2d1","swipeFinalSpeed","isSwipe","initialSupportedDirections","preventDefault","stopPropagation","$cb43891ac9a613e2$export$bdba51b3ce92d5f1","pointer_1","pointer_2","pointerIds","Set","pointerMap","globalVector_1","globalVector_2","centerHasBeenMoved","centerMovementDistance","centerMovementVector","getCenterMovementVector","absolutePointerDistanceChange","relativePointerDistanceChange","absoluteRotationAngle","vectorAngle","absoluteVectorAngle","liveVector_1","liveVector_2","centerIsMoving","removePointer","PointerEvent","globalCenter","globalCenterMovementVector","globalAbsoluteDistanceChange","calculateAbsoluteDistanceChange","globalRelativeDistanceChange","calculateRelativeDistanceChange","globalRotationAngle","calculateRotationAngle","globalVectorAngle","calculateVectorAngle","liveCenter","liveCenterMovementVector","liveAbsoluteDistanceChange","liveRelativeDistanceChange","liveRotationAngle","liveVectorAngle","$14d126af10d3d05a$export$f9d89efe4b7795e7","initialPointerEvent_1","initialPointerEvent_2","DualPointer","dualPointerInput","$df61fd58f18efccc$export$826ae541ddf1527b","$0fe9ad3b38405eae$export$152db69a76b6b79e","$6a2d57fd78e9a215$export$8847187e02a498e8","$7d1514273ccb6867$export$af6d1be017a420a","pointerAllocation","unusedPointers","onSurfacePointers","addPointer","pointerdownEvent","toString","pointerOptions","setActiveSinglePointerInput","setActiveDualPointerInput","currentPointerCount","has","remainingPointer","unusedPointerInput","getUnusedPointer","keys","values","getPointerFromId","$2cb62bc01322d9ff$var$ALL_GESTURE_CLASSES","$2cb62bc01322d9ff$export$9371bd96776f4e82","NoActiveGesture","activeGestures","hadActiveGestureDuringCurrentContact","gestureEventHandlers","lastRecognitionTimestamp","idleRecognitionIntervalId","pointerEventHandlers","touchEventHandlers","DEBUG_GESTURES","DEBUG_POINTERMANAGER","handleTouchEvents","consecutiveGestures","simultaneousGestures","supportedGestures","instantiatedGestures","map","GestureClass","gestureOptions","pointerManagerOptions","addPointerEventListeners","addTouchEventListeners","onPointerDown","bind","addEventListener","passive","pointerdown","pointermove","pointerup","pointercancel","setPointerCapture","clearIdleRecognitionInterval","setInterval","recognizeGestures","releasePointerCapture","removePointerEventListeners","handler","removeEventListener","removeTouchEventListeners","timedelta","clearInterval","gesturesForRecognition","ActiveGesture","updateActiveGestures","index","parseEventsString","eventsString","trim","split","on","handlerReference","eventTypes","e","eventType","capture","off","handlerList","destroy","h"],"version":3,"file":"index.js.map"}